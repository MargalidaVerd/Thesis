---
title: "TFG"
author: "Margalida Verd Juli√†"
format: html
editor: visual
---

## Installing data and packages

First, we will install and load the necessary packages for this study. Additionally, we will load the required datasets. The analysis is based on three datasets:

-   **Mortality**: Downloaded from the World Health Organization, this is the primary dataset for the analysis. It contains the number of tuberculosis-related deaths in all countries. However, our study will focus solely on European countries.

-   **Population**: From this dataset, we will extract only the population variable. The source of this data is *Our World in Data*.

-   **GDP per capita**: Similar to the population dataset, we will extract only the *gdp_per_capita* variable. The source of this data is *Data Bank*.

```{r, warning=FALSE, message=FALSE, echo= FALSE}

# packages loading

library(tidyverse)
library(readr)
library(dplyr)
library(zoo)
library(feasts)
library(eurostat)
library(leaflet)
library(sf)
library(scales)
library(cowplot)
library(ggthemes)
library(giscoR)
library(rnaturalearth)
library(ggplot2)
library(sf)
library(dplyr)
library(gridExtra)
library(grid)
library(tsibble)
library(tseries)
library(FinTS)
library(fable)
library(vctsfr)


```

Let's examine the structure of the datasets:

1.  Mortality:

```{r, warning=FALSE, message=FALSE, echo= FALSE}

# data loading

mortality_dataset <- read.csv("mortality.csv", header = TRUE, colClasses = c("character","character","character","character","double","character","character","character","double","double","double","double"), row.names = NULL) 

colnames(mortality_dataset) <- colnames(mortality_dataset)[2:ncol(mortality_dataset)]
mortality_dataset <- mortality_dataset[1:(ncol(mortality_dataset)-1)]

mortality_dataset %>% 
  glimpse()

unique(mortality_dataset$Age.group)
```

2.  Population

```{r, warning=FALSE, message=FALSE, echo= FALSE}
population_dataset <- read.csv("population.csv", header = TRUE)

population_dataset %>% 
  glimpse()
```

3.  gdp_per_capita

```{r, warning=FALSE, message=FALSE, echo= FALSE}
gdp_per_capita_dataset <- read.csv("gdp_per_capita.csv", header = TRUE)

gdp_per_capita_dataset %>% 
  glimpse()
```

## Cleaning data

As seen, we need to standardize the variables names to merge the tables.

```{r, warning=FALSE, message=FALSE, echo= FALSE}
# renaming variables

print("Mortality")

mortality_dataset <- mortality_dataset %>%  
  rename(number_deaths = Number, 
         year = Year, percent_cause_specific_death_rate = Percentage.of.cause.specific.deaths.out.of.total.deaths, age_death_rate = Age.standardized.death.rate.per.100.000.standard.population, death_rate = Death.rate.per.100.000.population, country_name = Country.Name, country_code = Country.Code, region_code = Region.Code, region_name = Region.Name) %>% 
  glimpse() 

print("Population")
population_dataset <- population_dataset %>% 
  rename(population = Population...Sex..all...Age..all...Variant..estimates, country_name = Entity, year = Year) %>% 
  glimpse() 

print("gdp_per_capita")
gdp_per_capita_dataset <- gdp_per_capita_dataset %>% 
  select(3,4,5,7) %>% 
  rename(country_name = Country.Name, country_code = Country.Code, year = Time, gdp_capita = Value) %>% 
  glimpse()

```

The next step is to select the study variables from the mortality dataset. We will exclude `Sex`, `Age.group.code` and `Age.group`.

```{r, warning=FALSE, message=FALSE, echo= FALSE}
# Select rows of interest in the mortality dataset

mortality_dataset <- mortality_dataset %>% 
  dplyr::filter(Sex == "All") 

# Delete age variables

mortality_dataset <- mortality_dataset %>% 
  select(1:5,9:12) %>% 
  glimpse()
```

Now, we can merge the remaining two datasets.

```{r, warning=FALSE, message=FALSE, echo= FALSE}
# joins

complete_data <- mortality_dataset %>% 
  left_join(population_dataset, by=c("country_name", "year")) %>% 
  left_join(gdp_per_capita_dataset, by = c("country_code", "year")) %>% 
  dplyr::filter(region_code=="EU") %>% 
  select(1:10,12) %>% 
  rename(country_name = country_name.x) 

complete_data %>% 
  glimpse()

```

## Chosen countries

First, we will define the criteria for dividing European countries into six distinct regions: North, South, West, East, Central, and the Balkans. The Balkans have been designated as a separate region due to their significant cultural differences from neighboring countries. We will add a new variable to the dataset that specifies the subregion to which each country belongs.

```{r, warning=FALSE, message=FALSE, echo= FALSE}

complete_data <- complete_data %>%
  mutate(subregion = case_when(
    country_name %in% c("Iceland", "Norway", "Sweden", "Finland", "Denmark") ~ "N",
    country_name %in% c("Spain", "Portugal", "Italy", "Malta", "Greece") ~ "S",
    country_name %in% c("Albania", "Bulgaria", "Romania", "Bosnia and Herzegovina", 
                "North Macedonia", "Croatia", "Serbia", "Montenegro", "Slovenia") ~ "B",
    country_name %in% c("France", "Netherlands", "Belgium", "United Kingdom", "Ireland") ~ "W",
    country_name %in% c("Russia", "Estonia", "Latvia", "Lithuania", "Belarus", "Ukraine", "Moldova") ~"E",
    country_name %in% c("Germany", "Poland", "Czechia", "Slovakia", "Hungary", 
                "Switzerland", "Austria", "Luxembourg") ~ "C" ,TRUE ~ NA_character_), .after = region_name)

```

The map below shows the division that would be used from this point forward.

```{r, warning=FALSE, message=FALSE, echo= FALSE}

# Load world map with country boundaries
world <- ne_countries(scale = "medium", returnclass = "sf")

# Filter only European countries
europe <- world %>% 
  filter(continent == "Europe")


# Define the classification
europe <- europe %>%
  mutate(Subregion = case_when(
    name %in% c("Iceland", "Norway", "Sweden", "Finland", "Denmark") ~ "N",
    name %in% c("Spain", "Portugal", "Italy", "Malta", 
                 "Greece") ~ "S",
    name %in% c("Albania", "Bulgaria", "Romania", "Kosovo", "Bosnia and Herz.", 
                "North Macedonia", "Croatia", "Serbia", "Montenegro", "Slovenia") ~ "B",
    name %in% c("France", "Netherlands", "Belgium", "United Kingdom", "Ireland") ~ "W",
    name %in% c("Russia", "Estonia", "Latvia", "Lithuania", "Belarus", "Ukraine", "Moldova") ~ "E",
    name %in% c("Germany", "Poland", "Czechia", "Slovakia", "Hungary", 
                "Switzerland", "Austria", "Luxembourg") ~ "C",
  ))


ggplot(data = europe) +
  geom_sf(aes(fill = Subregion), color = "black") +
  scale_fill_manual(values = c(
    "N" = "#F5BA6A",    
    "S" = "#4044A8",    
    "W" = "#CC4853",    
    "E" = "#5ED171",   
    "C" = "#F5E973",    
    "B" = "#66B0FA"    
  )) + scale_x_continuous(limits = c(-20, 35)) +
  scale_y_continuous(limits = c(35, 70)) +
  theme_minimal() +
  labs(
       fill = "Subregion") +
  theme(legend.position = "right")
```

We are considering Greece as part of the Southern region due to the cultural differences with the Balkan countries. Now, we would choose a country to represent each European subregion. We will select five European countries to analyze their trends in the number of tuberculosis-related deaths. The selection criteria will ensure that the chosen countries represent different regions of Europe (e.g., North, South, etc.) while also having a sufficient number of time observations to construct a reliable time series. Additionally, we aim to include countries that exhibit distinct trends in tuberculosis mortality, making the study more insightful by allowing for a comparative analysis and accurate forecasting of different patterns.

As a first step, we will address any missing values (NA) in the dataset for the variable Number_Deaths in each selected country. We are going to choose countries that at least have 40 years with data.

```{r, warning=FALSE, message=FALSE, echo= FALSE}

complete_data %>% 
  dplyr::select(country_name, number_deaths) %>% 
  na.exclude() %>%  
  group_by(country_name) %>% 
  count() %>% 
  arrange(desc(n)) %>% 
  data.frame() %>% 
  filter(n >= 40)

```

Lets study each subregion:

-   **Southern Europe**. Due to the geographical origin of the authors, we will choose Spain as the representative country of this region.

-   **Northern Europe**. We observe that Iceland has 72 out of 74 years with recorded values for the selected variable, making it a suitable choice to represent the North region of Europe.

-   **Western Europe**. As Netherlands is the country with a greatest number of values, it would be our choice for this specific region.

-   **Eastern Europe**. It is noticeable that eastern countries are the ones with a less number of recorded values (most of them have only 40 or less); then, it would be a special region to analyse. Lithuania will represent the Northeast region, with 40 recorded values. Even though there are nearby countries with longer recorded periods, the tendency of Lithuania stands out among the rest, which will make for an interesting analysis.

-   **Central Europe**. Switzerland will be the representative country of the central region. It has 71 recorded values, that will fit perfectly when modeling the time series.

-   **Balkans region**. For the Balkans region, we have selected Romania, which has 60 recorded values. It will be an interesting case of analysis due to its tendency, that is a bit different as the other countries.

The selection criteria prioritize minimizing the number of missing values (NA) while ensuring a diverse representation of different regions in Europe. As we have discussed trends, let's display the trend in tuberculosis-related deaths for the selected countries.

```{r, warning=FALSE, message=FALSE, echo= FALSE}

chosen_countries <- complete_data %>% 
  select(country_name, year, number_deaths) 

chosen_countries %>% 
  filter(country_name %in% c( "Spain", "Sweden", "Netherlands", "Switzerland", "Latvia", "Romania")) %>%  
  ggplot(aes(x = year, y = number_deaths, color = country_name)) +  
  geom_line() +
  coord_cartesian(ylim = c(0,2700)) +
  scale_color_manual(values = c(
    "Romania" = "#04A3BDFF",    
    "Switzerland" = "#F0BE3DFF",    
    "Latvia" = "#931E18FF",    
    "Sweden" = "#DA7901FF",   
    "Spain" = "#247D3FFF",    
    "Netherlands" = "#20235BFF"    
  )) + 
  theme_minimal() +
  ggtitle("Chosen countries trends")+
  theme(legend.position = "right") +
  ylab("Number of deaths")

```

```{r}

plot_spain <- chosen_countries %>% 
  filter(country_name == "Spain") %>%  
  ggplot(aes(x = year, y = number_deaths)) +  
  geom_line() +
  theme_minimal() +
  labs(title = "Spain" ) +
  theme(plot.title = element_text(hjust= 0.5, size = 10),
        axis.title.x = element_blank(),
        axis.title.y = element_blank())


plot_sweden <- chosen_countries %>% 
  filter(country_name == "Sweden") %>%  
  ggplot(aes(x = year, y = number_deaths)) +  
  geom_line() +
  theme_minimal() +
  labs(title = "Sweden", y = "Number of deaths") +
  theme(plot.title = element_text(hjust= 0.5, size = 10),
        axis.title.x = element_blank(),
        axis.title.y = element_blank())

plot_netherlands <- chosen_countries %>% 
  filter(country_name == "Netherlands") %>%  
  ggplot(aes(x = year, y = number_deaths)) +  
  geom_line() +
  theme_minimal() +
  labs(title = "Netherlands", y = "Number of deaths") +
  theme(plot.title = element_text(hjust= 0.5, size = 10),
        axis.title.x = element_blank(),
        axis.title.y = element_blank())

plot_romania <- chosen_countries %>% 
  filter(country_name == "Romania") %>%  
  ggplot(aes(x = year, y = number_deaths)) +  
  geom_line() +
  theme_minimal() +
  labs(title = "Romania", y = "Number of deaths") +
  theme(plot.title = element_text(hjust= 0.5, size = 10),
        axis.title.x = element_blank(),
        axis.title.y = element_blank())

plot_latvia <- chosen_countries %>% 
  filter(country_name == "Latvia") %>%  
  ggplot(aes(x = year, y = number_deaths)) +  
  geom_line() +
  theme_minimal() +
  labs(title = "Latvia", y = "Number of deaths") +
  theme(plot.title = element_text(hjust= 0.5, size = 10),
        axis.title.x = element_blank(),
        axis.title.y = element_blank())


plot_switzerland <- chosen_countries %>% 
  filter(country_name == "Switzerland") %>%  
  ggplot(aes(x = year, y = number_deaths)) +  
  geom_line() +
  theme_minimal() +
  labs(title = "Switzerland", y = "Number of deaths") +
  theme(plot.title = element_text(hjust= 0.5, size = 10),
        axis.title.x = element_blank(),
        axis.title.y = element_blank())

plot_spain
plot_switzerland
plot_sweden
plot_latvia
plot_romania
plot_netherlands

grid.arrange(
  plot_spain, 
  plot_switzerland, 
  plot_sweden, 
  plot_latvia, 
  plot_romania, 
  plot_netherlands, 
  nrow = 3,
  top = "TB mortality trends per country",
  bottom = textGrob(
    "Year",
    gp = gpar( fontsize = 10),
    hjust = 0),
  left = textGrob(
    "Number of deaths",
    gp = gpar(fontsize = 10),
    rot = 90,
    hjust = 0.5  )
)

```

## Detrending series

In order to build accurate time series models, the data must be stationary‚Äîmeaning it should exhibit constant mean and variance over time. Since developed countries (e.g., Spain, the Netherlands) show a strong downward trend in TB death counts over the years, we begin by transforming the original data using logarithms. This transformation stabilizes the variance and linearizes exponential trends, making the data more suitable for ARIMA modeling.

### Spain

We start with the Spanish data:

```{r, warning=FALSE, message=FALSE, echo= FALSE}

# Spain 

spain_data <- chosen_countries %>% 
  filter(country_name == "Spain") %>% 
  select(year, number_deaths) %>% 
  arrange(year)

vctsfr::plot_ts(ts(spain_data$number_deaths, start = c(1951), frequency = 1))

log_spain_data <- ts(log(spain_data$number_deaths), start = c(1951), frequency = 1)

vctsfr::plot_ts(log_spain_data)
```

Let's check the ACF and PACF of the series:

```{r, warning=FALSE, message=FALSE, echo= FALSE}
par(mfrow = c(2,2))
acf(log_spain_data)
pacf(log_spain_data)
```

Upon inspecting the ACF and PACF plots, we observe a strong autocorrelation in the undifferenced series, particularly at lower lags. To remove this non-stationarity, we apply first-order differencing:

```{r, warning=FALSE, message=FALSE, echo= FALSE}
log_spain_data_diff <- log_spain_data %>% 
  diff(differences = 1) 
```

The resulting ACF and PACF plots indicate that autocorrelations have been adequately removed, and the series is now stationary:

```{r, warning=FALSE, message=FALSE, echo= FALSE}
par(mfrow = c(2,2))
acf(log_spain_data_diff)
pacf(log_spain_data_diff)
```

We fit an ARIMA model automatically selected by auto.arima() from the forecast package, which chooses the best-fitting model based on information criteria (AICc by default):

```{r, warning=FALSE, message=FALSE, echo= FALSE}
fit_spain <- forecast::auto.arima(log_spain_data)
fit_spain
fit_spain %>% forecast::checkresiduals()

```
To properly check the normality of the residuals, we do the Shapiro-Wilk test:
```{r, warning=FALSE, message=FALSE, echo= FALSE}
shapiro.test(residuals(fit_spain))
```

The ARIMA model applied is the ARIMA(0,1,0), as it is the best suited fot the series. Residual diagnostics support this model. The Ljung-Box test yields a p-value of 0.9954, suggesting no significant autocorrelation in the residuals. However, the Shapiro-Wilk test for normality gave a p-value of 5.88√ó10‚Åª‚Åµ, leading us to reject the null hypothesis of normality. This implies that while the model captures the time dependence effectively, the residuals deviate from normality. To account for this, bootstrapping was enabled during forecasting to generate more robust prediction intervals.

Setting bootstrap = TRUE enables the computation of prediction intervals using bootstrapped innovations rather than assuming normality. This is particularly useful when residuals show slight deviations from normality or the model is very sensitive to error structure. Bootstrapping provides more robust and possibly asymmetric confidence intervals. However, it also increases computational time.

Now, to forecast future values, we apply the `forecast()`function:

```{r, warning=FALSE, message=FALSE, echo= FALSE}
forecasted_spain <- forecast(fit_spain,level = c(95), h=3, bootstrap = TRUE)
autoplot(forecasted_spain)
```

Next, we back-transform the forecasts to the original scale by applying the exponential function:

```{r, warning=FALSE, message=FALSE, echo= FALSE}
exp_forecasted_spain_fitted <- exp(forecasted_spain$fitted)
data <- spain_data %>% 
  mutate(exp_fitted = exp_forecasted_spain_fitted) 
data
```
The fitted values and forecasts are then plotted alongside the original series to assess model performance:
```{r, warning=FALSE, message=FALSE, echo= FALSE}

ggplot(data, aes(x = year)) +
  geom_line(aes(y = number_deaths, color = "Actual")) +
  geom_line(aes(y = exp_fitted, color = "Fitted"), linetype = "dashed") +
  labs(title = "Actual vs Fitted TB Deaths in Spain",
       x = "Year", y = "Number of Deaths",
       color = "Legend") +
  ylim(0,1000) +
  xlim(1980,2021) +
  theme_minimal()
```

To display the forecasts an their associated uncerainty, we prepare a data frame with the exponential of the forecast and confidence intervals:

```{r, warning=FALSE, message=FALSE, echo= FALSE}

df_forecast_spain <- data.frame(
  year = time(forecasted_spain$mean),
  mean = exp(forecasted_spain$mean),
  lower = exp(forecasted_spain$lower[,1]),
  upper = exp(forecasted_spain$upper[,1])
)

df_forecast_spain

```
Finally, we visualize the forecasts:

```{r, warning=FALSE, message=FALSE, echo= FALSE}

ggplot() +
  geom_line(data = spain_data, aes(x = year, y = number_deaths, color = "Actual")) +
  geom_line(data = df_forecast_spain, aes(x = year, y = mean, color = "Forecast"), linetype = "dashed") +
  geom_ribbon(data = df_forecast_spain, aes(x = year, ymin = lower, ymax = upper), alpha = 0.2, fill = "blue") +
  scale_color_manual(values = c("Actual" = "black", "Forecast" = "blue")) +
  labs(title = "TB Death forecast for Spain data",
       x = "Year", y = "Number deaths",
       color = "Serie") +
  coord_cartesian(xlim = c(2012, 2024), ylim = c(0,1000)) +
  theme_minimal()


```

The ARIMA(0,1,0) model applied to the log-transformed TB death series for Spain captures the downward trend effectively, with residual diagnostics confirming no significant autocorrelation. However, the residuals deviate from normality, which was addressed using bootstrapped forecasts to provide more reliable prediction intervals. The fitted values closely track the actual data, and the short-term forecasts show a continued decline in TB deaths, with relatively narrow confidence intervals, reflecting stability in the trend. These results suggest that ARIMA(0,1,0) is a simple yet adequate model for capturing and forecasting TB mortality trends in Spain.

### Netherlands

We now apply the same methodology to the Netherlands, a country that also shows a notable long-term decrease in TB deaths.

```{r}
netherlands_data <- chosen_countries %>% 
  filter(country_name == "Netherlands") %>% 
  select(year, number_deaths) %>% 
  arrange(year)
netherlands_data

vctsfr::plot_ts(ts(netherlands_data$number_deaths, start = c(1950), frequency = 1))

log_netherlands_data <- ts(log(netherlands_data$number_deaths), start = c(1950), frequency = 1)

vctsfr::plot_ts(log_spain_data)
```


```{r}
par(mfrow = c(2,2))
acf(log_netherlands_data)
pacf(log_netherlands_data)
```
We difference the series once:

```{r}
log_netherlands_data_diff <- log_netherlands_data %>% 
  diff(differences = 1) 
```

Now, let's check again the ACF and PACF:

```{r}
par(mfrow = c(2,2))
acf(log_netherlands_data_diff)
pacf(log_netherlands_data_diff)
```
The ACF slowly shows a possible significant lag at $t-1$. We will present two different models: ARIMA(0,1,0) and ARIMA(0,1,1).

```{r}
fit_netherlands_model_1 <- forecast::auto.arima(log_netherlands_data)
fit_netherlands_model_1

fit_netherlands_model_1 %>% forecast::checkresiduals()

```
For the ARIMA(0,1,1) the residuals pass the LB test. Now, let's see the residuals for the ARIMA(0,1,0):

```{r}
fit_netherlands_model_2 <- arima(log_netherlands_data, order = c(0,1,0))
fit_netherlands_model_2

fit_netherlands_model_2 %>% forecast::checkresiduals()
shapiro.test(residuals(fit_netherlands_model_2))
```

```{r}
forecasted_netherlands_1<- forecast(fit_netherlands_model_1,level = c(95), h=3, bootstrap = TRUE)
autoplot(forecasted_netherlands_1)
```

```{r}
exp_forecasted_netherlands_fitted_1 <- exp(forecasted_netherlands_1$fitted)

data_netherlands_1 <- netherlands_data %>% 
  mutate(exp_fitted = exp_forecasted_netherlands_fitted_1) 
data_netherlands_1

ggplot(data_netherlands_1, aes(x = year)) +
  geom_line(aes(y = number_deaths, color = "Actual")) +
  geom_line(aes(y = exp_fitted, color = "Fitted"), linetype = "dashed") +
  labs(title = "Actual vs Fitted TB Deaths in Netherlands with Arima(0,1,1)",
       x = "Year", y = "Number of Deaths",
       color = "Legend") +
  ylim(0,1000) +
  xlim(1980,2021) +
  theme_minimal()
```

```{r}

df_forecast_netherlands_1 <- data.frame(
  year = time(forecasted_netherlands_1$mean),
  mean = exp(forecasted_netherlands_1$mean),
  lower = exp(forecasted_netherlands_1$lower[,1]),
  upper = exp(forecasted_netherlands_1$upper[,1])
)

df_forecast_netherlands_1

```

```{r}

ggplot() +
  geom_line(data = netherlands_data, aes(x = year, y = number_deaths, color = "Actual")) +
  geom_line(data = df_forecast_netherlands_1, aes(x = year, y = mean, color = "Forecast"), linetype = "dashed") +
  geom_ribbon(data = df_forecast_netherlands_1, aes(x = year, ymin = lower, ymax = upper), alpha = 0.2, fill = "blue") +
  scale_color_manual(values = c("Actual" = "black", "Forecast" = "blue")) +
  labs(title = "Forecast",
       x = "Year", y = "Number deaths",
       color = "Serie") +
  coord_cartesian(xlim = c(2012, 2024), ylim = c(0,1000)) +
  theme_minimal()


```
Now let's study the second adjusted model for the Netherlands series.

```{r}
forecasted_netherlands_2 <- forecast(fit_netherlands_model_2,level = c(95), h=3, bootstrap = TRUE)
autoplot(forecasted_netherlands_2)
```

```{r}
exp_forecasted_netherlands_fitted_2 <- exp(forecasted_netherlands_2$fitted)

data_netherlands_2 <- netherlands_data %>% 
  mutate(exp_fitted = exp_forecasted_netherlands_fitted_2) 
data_netherlands_2

ggplot(data_netherlands_2, aes(x = year)) +
  geom_line(aes(y = number_deaths, color = "Actual")) +
  geom_line(aes(y = exp_fitted, color = "Fitted"), linetype = "dashed") +
  labs(title = "Actual vs Fitted TB Deaths in Netherlands with Arima(0,1,1)",
       x = "Year", y = "Number of Deaths",
       color = "Legend") +
  ylim(0,1000) +
  xlim(1980,2021) +
  theme_minimal()
```

```{r}

df_forecast_netherlands_2 <- data.frame(
  year = time(forecasted_netherlands_2$mean),
  mean = exp(forecasted_netherlands_2$mean),
  lower = exp(forecasted_netherlands_2$lower[,1]),
  upper = exp(forecasted_netherlands_2$upper[,1])
)

df_forecast_netherlands_2

```

```{r}

ggplot() +
  geom_line(data = netherlands_data, aes(x = year, y = number_deaths, color = "Actual")) +
  geom_line(data = df_forecast_netherlands_2, aes(x = year, y = mean, color = "Forecast"), linetype = "dashed") +
  geom_ribbon(data = df_forecast_netherlands_2, aes(x = year, ymin = lower, ymax = upper), alpha = 0.2, fill = "blue") +
  scale_color_manual(values = c("Actual" = "black", "Forecast" = "blue")) +
  labs(title = "Forecast",
       x = "Year", y = "Number deaths",
       color = "Serie") +
  coord_cartesian(xlim = c(2012, 2024), ylim = c(0,1000)) +
  theme_minimal()


```



