---
title: "TFG"
author: "Margalida Verd Juli√†"
format: html
editor: visual
---

## Installing data and packages

First, we will install and load the necessary packages for this study. Additionally, we will load the required datasets. The analysis is based on three datasets:

-   **Mortality**: Downloaded from the World Health Organization, this is the primary dataset for the analysis. It contains the number of tuberculosis-related deaths in all countries. However, our study will focus solely on European countries.

-   **Population**: From this dataset, we will extract only the population variable. The source of this data is *Our World in Data*.

-   **GDP per capita**: Similar to the population dataset, we will extract only the *gdp_per_capita* variable. The source of this data is *Data Bank*.

```{r, warning=FALSE, message=FALSE, echo= FALSE}

# packages loading

library(tidyverse)
library(readr)
library(dplyr)
library(zoo)
library(feasts)
library(eurostat)
library(leaflet)
library(sf)
library(scales)
library(cowplot)
library(ggthemes)
library(giscoR)
library(rnaturalearth)
library(ggplot2)
library(sf)
library(dplyr)
library(gridExtra)
library(grid)
library(tsibble)
library(tseries)
library(FinTS)
library(fable)
library(vctsfr)
library(fpp2)


```

Let's examine the structure of the datasets:

1.  Mortality:

```{r, warning=FALSE, message=FALSE, echo= FALSE}

# data loading

mortality_dataset <- read.csv("mortality.csv", header = TRUE, colClasses = c("character","character","character","character","double","character","character","character","double","double","double","double"), row.names = NULL) 

colnames(mortality_dataset) <- colnames(mortality_dataset)[2:ncol(mortality_dataset)]
mortality_dataset <- mortality_dataset[1:(ncol(mortality_dataset)-1)]

mortality_dataset %>% 
  glimpse()

unique(mortality_dataset$Age.group)
```

2.  Population

```{r, warning=FALSE, message=FALSE, echo= FALSE}
population_dataset <- read.csv("population.csv", header = TRUE)

population_dataset %>% 
  glimpse()
```

3.  gdp_per_capita

```{r, warning=FALSE, message=FALSE, echo= FALSE}
gdp_per_capita_dataset <- read.csv("gdp_per_capita.csv", header = TRUE)

gdp_per_capita_dataset %>% 
  glimpse()
```

## Cleaning data

As seen, we need to standardize the variables names to merge the tables.

```{r, warning=FALSE, message=FALSE, echo= FALSE}
# renaming variables

print("Mortality")

mortality_dataset <- mortality_dataset %>%  
  rename(number_deaths = Number, 
         year = Year, percent_cause_specific_death_rate = Percentage.of.cause.specific.deaths.out.of.total.deaths, age_death_rate = Age.standardized.death.rate.per.100.000.standard.population, death_rate = Death.rate.per.100.000.population, country_name = Country.Name, country_code = Country.Code, region_code = Region.Code, region_name = Region.Name) %>% 
  glimpse() 

print("Population")
population_dataset <- population_dataset %>% 
  rename(population = Population...Sex..all...Age..all...Variant..estimates, country_name = Entity, year = Year) %>% 
  glimpse() 

print("gdp_per_capita")
gdp_per_capita_dataset <- gdp_per_capita_dataset %>% 
  select(3,4,5,7) %>% 
  rename(country_name = Country.Name, country_code = Country.Code, year = Time, gdp_capita = Value) %>% 
  glimpse()

```

The next step is to select the study variables from the mortality dataset. We will exclude `Sex`, `Age.group.code` and `Age.group`.

```{r, warning=FALSE, message=FALSE, echo= FALSE}
# Select rows of interest in the mortality dataset

mortality_dataset <- mortality_dataset %>% 
  dplyr::filter(Sex == "All") 

# Delete age variables

mortality_dataset <- mortality_dataset %>% 
  select(1:5,9:12) %>% 
  glimpse()
```

Now, we can merge the remaining two datasets.

```{r, warning=FALSE, message=FALSE, echo= FALSE}
# joins

complete_data <- mortality_dataset %>% 
  left_join(population_dataset, by=c("country_name", "year")) %>% 
  left_join(gdp_per_capita_dataset, by = c("country_code", "year")) %>% 
  dplyr::filter(region_code=="EU") %>% 
  select(1:10,12) %>% 
  rename(country_name = country_name.x) 

complete_data %>% 
  glimpse()

```

## Chosen countries

First, we will define the criteria for dividing European countries into six distinct regions: North, South, West, East, Central, and the Balkans. The Balkans have been designated as a separate region due to their significant cultural differences from neighboring countries. We will add a new variable to the dataset that specifies the subregion to which each country belongs.

```{r, warning=FALSE, message=FALSE, echo= FALSE}

complete_data <- complete_data %>%
  mutate(subregion = case_when(
    country_name %in% c("Iceland", "Norway", "Sweden", "Finland", "Denmark") ~ "N",
    country_name %in% c("Spain", "Portugal", "Italy", "Malta", "Greece") ~ "S",
    country_name %in% c("Albania", "Bulgaria", "Romania", "Bosnia and Herzegovina", 
                "North Macedonia", "Croatia", "Serbia", "Montenegro", "Slovenia") ~ "B",
    country_name %in% c("France", "Netherlands", "Belgium", "United Kingdom", "Ireland") ~ "W",
    country_name %in% c("Russia", "Estonia", "Latvia", "Lithuania", "Belarus", "Ukraine", "Moldova") ~"E",
    country_name %in% c("Germany", "Poland", "Czechia", "Slovakia", "Hungary", 
                "Switzerland", "Austria", "Luxembourg") ~ "C" ,TRUE ~ NA_character_), .after = region_name)

```

The map below shows the division that would be used from this point forward.

```{r, warning=FALSE, message=FALSE, echo= FALSE}

# Load world map with country boundaries
world <- ne_countries(scale = "medium", returnclass = "sf")

# Filter only European countries
europe <- world %>% 
  filter(continent == "Europe")


# Define the classification
europe <- europe %>%
  mutate(Subregion = case_when(
    name %in% c("Iceland", "Norway", "Sweden", "Finland", "Denmark") ~ "N",
    name %in% c("Spain", "Portugal", "Italy", "Malta", 
                 "Greece") ~ "S",
    name %in% c("Albania", "Bulgaria", "Romania", "Kosovo", "Bosnia and Herz.", 
                "North Macedonia", "Croatia", "Serbia", "Montenegro", "Slovenia") ~ "B",
    name %in% c("France", "Netherlands", "Belgium", "United Kingdom", "Ireland") ~ "W",
    name %in% c("Russia", "Estonia", "Latvia", "Lithuania", "Belarus", "Ukraine", "Moldova") ~ "E",
    name %in% c("Germany", "Poland", "Czechia", "Slovakia", "Hungary", 
                "Switzerland", "Austria", "Luxembourg") ~ "C",
  ))


ggplot(data = europe) +
  geom_sf(aes(fill = Subregion), color = "black") +
  scale_fill_manual(values = c(
    "N" = "#F5BA6A",    
    "S" = "#4044A8",    
    "W" = "#CC4853",    
    "E" = "#5ED171",   
    "C" = "#F5E973",    
    "B" = "#66B0FA"    
  )) + scale_x_continuous(limits = c(-20, 35)) +
  scale_y_continuous(limits = c(35, 70)) +
  theme_minimal() +
  labs(
       fill = "Subregion") +
  theme(legend.position = "right")
```

We are considering Greece as part of the Southern region due to the cultural differences with the Balkan countries. Now, we would choose a country to represent each European subregion. We will select five European countries to analyze their trends in the number of tuberculosis-related deaths. The selection criteria will ensure that the chosen countries represent different regions of Europe (e.g., North, South, etc.) while also having a sufficient number of time observations to construct a reliable time series. Additionally, we aim to include countries that exhibit distinct trends in tuberculosis mortality, making the study more insightful by allowing for a comparative analysis and accurate forecasting of different patterns.

As a first step, we will address any missing values (NA) in the dataset for the variable Number_Deaths in each selected country. We are going to choose countries that at least have 40 years with data.

```{r, warning=FALSE, message=FALSE, echo= FALSE}

complete_data %>% 
  dplyr::select(country_name, number_deaths) %>% 
  na.exclude() %>%  
  group_by(country_name) %>% 
  count() %>% 
  arrange(desc(n)) %>% 
  data.frame() %>% 
  filter(n >= 40)

```

Lets study each subregion:

-   **Southern Europe**. Due to the geographical origin of the authors, we will choose Spain as the representative country of this region.

-   **Northern Europe**. We observe that Iceland has 72 out of 74 years with recorded values for the selected variable, making it a suitable choice to represent the North region of Europe.

-   **Western Europe**. As Netherlands is the country with a greatest number of values, it would be our choice for this specific region.

-   **Eastern Europe**. It is noticeable that eastern countries are the ones with a less number of recorded values (most of them have only 40 or less); then, it would be a special region to analyse. Lithuania will represent the Northeast region, with 40 recorded values. Even though there are nearby countries with longer recorded periods, the tendency of Lithuania stands out among the rest, which will make for an interesting analysis.

-   **Central Europe**. Switzerland will be the representative country of the central region. It has 71 recorded values, that will fit perfectly when modeling the time series.

-   **Balkans region**. For the Balkans region, we have selected Romania, which has 60 recorded values. It will be an interesting case of analysis due to its tendency, that is a bit different as the other countries.

The selection criteria prioritize minimizing the number of missing values (NA) while ensuring a diverse representation of different regions in Europe. As we have discussed trends, let's display the trend in tuberculosis-related deaths for the selected countries.

```{r, warning=FALSE, message=FALSE, echo= FALSE}

chosen_countries <- complete_data %>% 
  select(country_name, year, number_deaths) 

chosen_countries %>% 
  filter(country_name %in% c( "Spain", "Sweden", "Netherlands", "Switzerland", "Latvia", "Romania")) %>%  
  ggplot(aes(x = year, y = number_deaths, color = country_name)) +  
  geom_line() +
  coord_cartesian(ylim = c(0,2700)) +
  scale_color_manual(values = c(
    "Romania" = "#04A3BDFF",    
    "Switzerland" = "#F0BE3DFF",    
    "Latvia" = "#931E18FF",    
    "Sweden" = "#DA7901FF",   
    "Spain" = "#247D3FFF",    
    "Netherlands" = "#20235BFF"    
  )) + 
  theme_minimal() +
  ggtitle("Chosen countries trends")+
  theme(legend.position = "right") +
  ylab("Number of deaths")

```

```{r}

plot_spain <- chosen_countries %>% 
  filter(country_name == "Spain") %>%  
  ggplot(aes(x = year, y = number_deaths)) +  
  geom_line() +
  theme_minimal() +
  labs(title = "Spain" ) +
  theme(plot.title = element_text(hjust= 0.5, size = 10),
        axis.title.x = element_blank(),
        axis.title.y = element_blank())


plot_sweden <- chosen_countries %>% 
  filter(country_name == "Sweden") %>%  
  ggplot(aes(x = year, y = number_deaths)) +  
  geom_line() +
  theme_minimal() +
  labs(title = "Sweden", y = "Number of deaths") +
  theme(plot.title = element_text(hjust= 0.5, size = 10),
        axis.title.x = element_blank(),
        axis.title.y = element_blank())

plot_netherlands <- chosen_countries %>% 
  filter(country_name == "Netherlands") %>%  
  ggplot(aes(x = year, y = number_deaths)) +  
  geom_line() +
  theme_minimal() +
  labs(title = "Netherlands", y = "Number of deaths") +
  theme(plot.title = element_text(hjust= 0.5, size = 10),
        axis.title.x = element_blank(),
        axis.title.y = element_blank())

plot_romania <- chosen_countries %>% 
  filter(country_name == "Romania") %>%  
  ggplot(aes(x = year, y = number_deaths)) +  
  geom_line() +
  theme_minimal() +
  labs(title = "Romania", y = "Number of deaths") +
  theme(plot.title = element_text(hjust= 0.5, size = 10),
        axis.title.x = element_blank(),
        axis.title.y = element_blank())

plot_latvia <- chosen_countries %>% 
  filter(country_name == "Latvia") %>%  
  ggplot(aes(x = year, y = number_deaths)) +  
  geom_line() +
  theme_minimal() +
  labs(title = "Latvia", y = "Number of deaths") +
  theme(plot.title = element_text(hjust= 0.5, size = 10),
        axis.title.x = element_blank(),
        axis.title.y = element_blank())


plot_switzerland <- chosen_countries %>% 
  filter(country_name == "Switzerland") %>%  
  ggplot(aes(x = year, y = number_deaths)) +  
  geom_line() +
  theme_minimal() +
  labs(title = "Switzerland", y = "Number of deaths") +
  theme(plot.title = element_text(hjust= 0.5, size = 10),
        axis.title.x = element_blank(),
        axis.title.y = element_blank())

plot_spain
plot_switzerland
plot_sweden
plot_latvia
plot_romania
plot_netherlands

grid.arrange(
  plot_spain, 
  plot_switzerland, 
  plot_sweden, 
  plot_latvia, 
  plot_romania, 
  plot_netherlands, 
  nrow = 3,
  top = "TB mortality trends per country",
  bottom = textGrob(
    "Year",
    gp = gpar( fontsize = 10),
    hjust = 0),
  left = textGrob(
    "Number of deaths",
    gp = gpar(fontsize = 10),
    rot = 90,
    hjust = 0.5  )
)

```

## ARIMA models

In order to build accurate time series models, the data must be stationary‚Äîmeaning it should exhibit constant mean and variance over time. Since developed countries (e.g., Spain, the Netherlands) show a strong downward trend in TB death counts over the years, we begin by transforming the original data using logarithms. This transformation stabilizes the variance and linearizes exponential trends, making the data more suitable for ARIMA modeling.

### Spain

We start with the Spanish data:

```{r, warning=FALSE, message=FALSE, echo= FALSE}

# Spain 

spain_data <- chosen_countries %>% 
  filter(country_name == "Spain") %>% 
  select(year, number_deaths) %>% 
  arrange(year)

#vctsfr::plot_ts(ts(spain_data$number_deaths, start = c(1951), frequency = 1)) + 
#  theme_minimal() 

log_spain_data <- ts(log(spain_data$number_deaths), start = c(1951), frequency = 1)

plot_ts(log_spain_data) +
  theme_minimal() +
  labs(
    title = " ",
    x = "Year",
    y = "Log(Number of deaths)"
  ) +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13)
  )
```

Let's check the ACF and PACF of the series:

```{r, warning=FALSE, message=FALSE, echo= FALSE}
par(mfrow = c(2,2))
acf(log_spain_data) 
pacf(log_spain_data)
```

Upon inspecting the ACF and PACF plots, we observe a strong autocorrelation in the undifferenced series, particularly at lower lags. To remove this non-stationarity, we apply first-order differencing:

```{r, warning=FALSE, message=FALSE, echo= FALSE}
log_spain_data_diff <- log_spain_data %>% 
  diff(differences = 1) 
plot_ts(log_spain_data_diff)
```

The resulting ACF and PACF plots indicate that autocorrelations have been adequately removed, and the series is now stationary:

```{r, warning=FALSE, message=FALSE, echo= FALSE}
par(mfrow = c(2,2))
acf(log_spain_data_diff)
pacf(log_spain_data_diff)
```

We fit an ARIMA model automatically selected by auto.arima() from the forecast package, which chooses the best-fitting model based on information criteria (AICc by default):

```{r, warning=FALSE, message=FALSE, echo= FALSE}
fit_spain <- forecast::auto.arima(log_spain_data)
fit_spain
fit_spain %>% forecast::checkresiduals()

```

To properly check the normality of the residuals, we do the Shapiro-Wilk test:

```{r, warning=FALSE, message=FALSE, echo= FALSE}
shapiro.test(residuals(fit_spain))
```

The ARIMA model applied is the ARIMA(0,1,0), as it is the best suited fot the series. Residual diagnostics support this model. The Ljung-Box test yields a p-value of 0.9954, suggesting no significant autocorrelation in the residuals. However, the Shapiro-Wilk test for normality gave a p-value of 5.88√ó10‚Åª‚Åµ, leading us to reject the null hypothesis of normality. This implies that while the model captures the time dependence effectively, the residuals deviate from normality. To account for this, bootstrapping was enabled during forecasting to generate more robust prediction intervals.

Setting bootstrap = TRUE enables the computation of prediction intervals using bootstrapped innovations rather than assuming normality.

Now, to forecast future values, we apply the `forecast()`function:

```{r, warning=FALSE, message=FALSE, echo= FALSE}
forecasted_spain <- forecast(fit_spain,level = c(95), h=3, bootstrap = TRUE)

par(mfrow = c(2,2))

autoplot(forecasted_spain) +
  theme_minimal() +
  labs(
    title = "Forecasts from ARIMA(0,1,0) for Spain series",
    x = "Year",
    y = "Log(Number of deaths)"
  ) +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13)
  )

autoplot(forecasted_spain) +
  theme_minimal() +
  labs(
    title = "Forecasts from ARIMA(0,1,0) for Spain series",
    x = "Year",
    y = "Log(Number of deaths)"
  ) +
  xlim(2010,2024) +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13)
  )
```

Next, we back-transform the forecasts to the original scale by applying the exponential function:

```{r, warning=FALSE, message=FALSE, echo= FALSE}
exp_forecasted_spain_fitted <- exp(forecasted_spain$fitted)
data <- spain_data %>% 
  mutate(exp_fitted = exp_forecasted_spain_fitted) 
data
```

The fitted values and forecasts are then plotted alongside the original series to assess model performance:

```{r, warning=FALSE, message=FALSE, echo= FALSE}

ggplot(data, aes(x = year)) +
  geom_line(aes(y = number_deaths, color = "Actual")) +
  geom_line(aes(y = exp_fitted, color = "Fitted"), linetype = "dashed") +
  scale_color_manual(
    values = c("Actual" = "#1f77b4",  
               "Fitted" = "#ff7f0e")  
  ) +
  labs(title = "Actual vs Fitted TB deaths in Spain",
       x = "Year", y = "Number of Deaths",
       color = "Legend") +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13)
  )

ggplot(data, aes(x = year)) +
  geom_line(aes(y = number_deaths, color = "Actual")) +
  geom_line(aes(y = exp_fitted, color = "Fitted"), linetype = "dashed") +
  scale_color_manual(
    values = c("Actual" = "#1f77b4",  
               "Fitted" = "#ff7f0e")  
  ) +
  labs(title = "Actual vs Fitted TB deaths in Spain",
       subtitle = "Zoomed-in segment of the TB mortality time series in Spain (1980‚Äì2021)",
       x = "Year", y = "Number of Deaths",
       color = "Legend") +
  ylim(0,1000) +
  xlim(1980,2021) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    plot.subtitle = element_text(size = 12),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13)
  )
```

To display the forecasts an their associated uncerainty, we prepare a data frame with the exponential of the forecast and confidence intervals:

```{r, warning=FALSE, message=FALSE, echo= FALSE}

df_forecast_spain <- data.frame(
  year = time(forecasted_spain$mean),
  mean = exp(forecasted_spain$mean),
  lower = exp(forecasted_spain$lower[,1]),
  upper = exp(forecasted_spain$upper[,1])
)

df_forecast_spain

```

Finally, we visualize the forecasts:

```{r, warning=FALSE, message=FALSE, echo= FALSE}

ggplot() +
  geom_line(data = spain_data, aes(x = year, y = number_deaths, color = "Actual")) +
  geom_line(data = df_forecast_spain, aes(x = year, y = mean, color = "Forecast"), linetype = "dashed") +
  geom_ribbon(data = df_forecast_spain, aes(x = year, ymin = lower, ymax = upper), alpha = 0.2, fill = "#ff7f0e") +
  scale_color_manual(values = c("Actual" = "#1f77b4", "Forecast" = "#ff7f0e")) +
  labs(title = "Forecast for Spain data",
       subtitle = "Complete series",
       x = "Year", y = "Number deaths",
       color = "Serie") +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold", size = 16),
    plot.subtitle = element_text(size = 12),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13) )


ggplot() +
  geom_line(data = spain_data, aes(x = year, y = number_deaths, color = "Actual")) +
  geom_line(data = df_forecast_spain, aes(x = year, y = mean, color = "Forecast"), linetype = "dashed") +
  geom_ribbon(data = df_forecast_spain, aes(x = year, ymin = lower, ymax = upper), alpha = 0.2, fill = "#ff7f0e") +
  scale_color_manual(values = c("Actual" = "#1f77b4", "Forecast" = "#ff7f0e")) +
  labs(title = "TB Death forecast for Spain data",
       subtitle = "Zoomed-in forecast (2012-2024)",
       x = "Year", y = "Number deaths",
       color = "Serie") +
  coord_cartesian(xlim = c(2012, 2024), ylim = c(0,1000)) +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold", size = 16),
    plot.subtitle = element_text(size = 12),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13) )


```

The ARIMA(0,1,0) model applied to the log-transformed TB death series for Spain captures the downward trend effectively, with residual diagnostics confirming no significant autocorrelation. However, the residuals deviate from normality, which was addressed using bootstrapped forecasts to provide more reliable prediction intervals. The fitted values closely track the actual data, and the short-term forecasts show a continued decline in TB deaths, with relatively narrow confidence intervals, reflecting stability in the trend. These results suggest that ARIMA(0,1,0) is a simple yet adequate model for capturing and forecasting TB mortality trends in Spain.

### Netherlands

We now apply the same methodology to the Netherlands, a country that also shows a notable long-term decrease in TB deaths.

```{r, warning=FALSE, message=FALSE, echo= FALSE}
netherlands_data <- chosen_countries %>% 
  filter(country_name == "Netherlands") %>% 
  select(year, number_deaths) %>% 
  arrange(year)

#vctsfr::plot_ts(ts(netherlands_data$number_deaths, start = c(1950), frequency = 1))

log_netherlands_data <- ts(log(netherlands_data$number_deaths), start = c(1950), frequency = 1)

plot_ts(log_netherlands_data) +
  theme_minimal() +
  labs(
    title = "Log-transformed time series of tuberculosis deaths in the Netherlands",
    x = "Year",
    y = "Log(Number of deaths)"
  ) +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13)
  )
```

```{r, warning=FALSE, message=FALSE, echo= FALSE}
par(mfrow = c(2,2))
acf(log_netherlands_data)
pacf(log_netherlands_data)
```
We first apply the same model as for Spain data: ARIMA(0,1,0).

```{r, warning=FALSE, message=FALSE, echo= FALSE}
fit_netherlands <- arima(log_netherlands_data, order = c(0,1,0))
fit_netherlands
```
The AIC coefficient seems to be low, so at first sight might seem a good approach. Let us check the residuals:

```{r, warning=FALSE, message=FALSE, echo= FALSE}

fit_netherlands%>% forecast::checkresiduals()
shapiro.test(residuals(fit_netherlands))
```
The residuals pass the Ljung-Box test for autocorrelation; however, they do not pass the normality test. For that reason, we will forecast future values using the bootsrap feature.

Now, we difference the series:

```{r, warning=FALSE, message=FALSE, echo= FALSE}
log_netherlands_data_diff <- log_netherlands_data %>% 
  diff(differences = 1) 
```

We begin the forecast:

```{r, warning=FALSE, message=FALSE, echo= FALSE}
forecasted_netherlands <- forecast(fit_netherlands,level = c(95), h=3, bootstrap = TRUE)
forecasted_netherlands

autoplot(forecasted_netherlands) +
  theme_minimal() +
  labs(
    title = "Forecasts from ARIMA(0,1,0) for Netherlands series",
    x = "Year",
    y = "Log(Number of deaths)"
  ) +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13)
  )

autoplot(forecasted_netherlands) +
  theme_minimal() +
  labs(
    title = "Forecasts from ARIMA(0,1,0) for Netherlands series",
    subtitle = "Zoomed-in series (2010-2024)",
    x = "Year",
    y = "Log(Number of deaths)"
  ) +
  xlim(2010,2024) +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    plot.subtitle = element_text(size = 14),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13)
  )

```
A noticeable observation is that the predicted values remain constant over a three-year period, suggesting that the model may not be well-suited for forecasting this time series. Nevertheless, let's visualize the actual versus fitted values to better assess the model's performance.

```{r, warning=FALSE, message=FALSE, echo= FALSE}
exp_forecasted_netherlands_fitted <- exp(forecasted_netherlands$fitted)

data_netherlands <- netherlands_data %>% 
  mutate(exp_fitted = round(exp_forecasted_netherlands_fitted)) %>% 
  mutate(difference = round(exp_fitted - number_deaths))

data_netherlands

```

The differences between the real values and the fitted ones differ significantly. Graphically:

```{r, warning=FALSE, message=FALSE, echo= FALSE}

ggplot(data_netherlands, aes(x = year)) +
  geom_line(aes(y = number_deaths, color = "Actual")) +
  geom_line(aes(y = exp_fitted, color = "Fitted"), linetype = "dashed") +
  labs(title = "Actual vs Fitted TB Deaths in Netherlands with Arima(0,1,0)",
       x = "Year", y = "Number of Deaths",
       color = "Legend") +
  scale_color_manual(
    values = c("Actual" = "#1f77b4",  
               "Fitted" = "#ff7f0e")  
  ) +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold", size = 16),
    plot.subtitle = element_text(size = 14),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13))

ggplot(data_netherlands, aes(x = year)) +
  geom_line(aes(y = number_deaths, color = "Actual")) +
  geom_line(aes(y = exp_fitted, color = "Fitted"), linetype = "dashed") +
  labs(title = "Actual vs Fitted TB Deaths in Netherlands with Arima(0,1,0)",
       subtitle = "Zoomed-in Netherlands forecast (1980-2021)",
       x = "Year", y = "Number of Deaths",
       color = "Legend") +
  scale_color_manual(
    values = c("Actual" = "#1f77b4",  
               "Fitted" = "#ff7f0e")  
  ) +
  ylim(0,300) +
  xlim(1980,2021) +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold", size = 16),
    plot.subtitle = element_text(size = 14),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13))
```
We see the forecasted points and boundaries in exponential scale:

```{r, warning=FALSE, message=FALSE, echo= FALSE}

df_forecast_netherlands <- data.frame(
  year = time(forecasted_netherlands$mean),
  mean = exp(forecasted_netherlands$mean),
  lower = exp(forecasted_netherlands$lower[,1]),
  upper = exp(forecasted_netherlands$upper[,1])
)

df_forecast_netherlands

```
Finally, we plot the forecasted values in the original scale:

```{r, warning=FALSE, message=FALSE, echo= FALSE}

ggplot() +
  geom_line(data = netherlands_data, aes(x = year, y = number_deaths, color = "Actual")) +
  geom_line(data = df_forecast_netherlands_2, aes(x = year, y = mean, color = "Forecast"), linetype = "dashed") +
  geom_ribbon(data = df_forecast_netherlands_2, aes(x = year, ymin = lower, ymax = upper), alpha = 0.2, fill = "#ff7f0e") +
  scale_color_manual(values = c("Actual" = "#1f77b4", "Forecast" = "#ff7f0e")) +
  labs(title = "TB Death forecast for Netherlands data",
       x = "Year", y = "Number deaths",
       color = "Serie") +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold", size = 16),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13) )

ggplot() +
  geom_line(data = netherlands_data, aes(x = year, y = number_deaths, color = "Actual")) +
  geom_line(data = df_forecast_netherlands_2, aes(x = year, y = mean, color = "Forecast"), linetype = "dashed") +
  geom_ribbon(data = df_forecast_netherlands_2, aes(x = year, ymin = lower, ymax = upper), alpha = 0.2, fill = "#ff7f0e") +
  scale_color_manual(values = c("Actual" = "#1f77b4", "Forecast" = "#ff7f0e")) +
  labs(title = "TB Death forecast for Netherlands data",
       subtitle = "Zoomed-in forecast (2012-2024) - ARIMA(0,1,0)",
       x = "Year", y = "Number deaths",
       color = "Serie") +
  theme_minimal() +
  coord_cartesian(xlim = c(2012, 2024), ylim = c(0,100)) +
  theme(plot.title = element_text(face = "bold", size = 16),
    plot.subtitle = element_text(size = 12),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13) )


```
As seen, ARIMA(0,1,0) may not fit well for this series. Now, we will use the `auto.arima()` function in order to present a new model:

```{r, warning=FALSE, message=FALSE, echo= FALSE}
fit_netherlands_auto <- forecast::auto.arima(log_netherlands_data)
fit_netherlands_auto

```
The model suggested is an ARIMA(0,1,1). Let us check the residuals:

```{r, warning=FALSE, message=FALSE, echo= FALSE}
fit_netherlands_auto %>% forecast::checkresiduals()
shapiro.test(residuals(fit_netherlands_auto))
```

The residuals of this new model pass the autocorrelation test; however, they neither pass the normality test. Once again, bootstrap will be applied when forecasting.


```{r, warning=FALSE, message=FALSE, echo= FALSE}
forecasted_netherlands_auto <- forecast(fit_netherlands_auto,level = c(95), h=3, bootstrap = TRUE)
forecasted_netherlands_auto

autoplot(forecasted_netherlands_auto) +
  theme_minimal() +
  labs(
    title = "Forecasts from ARIMA(0,1,1) for Netherlands series",
    x = "Year",
    y = "Log(Number of deaths)"
  ) +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13)
  )

autoplot(forecasted_netherlands_auto) +
  theme_minimal() +
  labs(
    title = "Forecasts from ARIMA(0,1,1) for Netherlands series",
    x = "Year",
    y = "Log(Number of deaths)"
  ) +
  ylim(2,5) +
  xlim(2010,2026) +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13)
  )
```
Let's back-transform the forecasted values into the original scale:

```{r, warning=FALSE, message=FALSE, echo= FALSE}
exp_forecasted_netherlands_fitted_auto <- exp(forecasted_netherlands_auto$fitted)

data_netherlands_auto <- netherlands_data %>% 
  mutate(exp_fitted = exp_forecasted_netherlands_fitted_auto) 

data_netherlands_auto
```

```{r, warning=FALSE, message=FALSE, echo= FALSE}

ggplot(data_netherlands_auto, aes(x = year)) +
  geom_line(aes(y = number_deaths, color = "Actual")) +
  geom_line(aes(y = exp_fitted, color = "Fitted"), linetype = "dashed") +
  labs(title = "Actual vs Fitted TB Deaths in Netherlands with Arima(0,1,0)",
       x = "Year", y = "Number of Deaths",
       color = "Legend") +
  scale_color_manual(
    values = c("Actual" = "#1f77b4",  
               "Fitted" = "#ff7f0e")  
  ) +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold", size = 14),
    plot.subtitle = element_text(size = 14),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13))


ggplot(data_netherlands_auto, aes(x = year)) +
  geom_line(aes(y = number_deaths, color = "Actual")) +
  geom_line(aes(y = exp_fitted, color = "Fitted"), linetype = "dashed") +
  labs(title = "Actual vs Fitted TB Deaths in Netherlands with Arima(0,1,1)",
       x = "Year", y = "Number of Deaths",
       color = "Legend") +
  scale_color_manual(
    values = c("Actual" = "#1f77b4",  
               "Fitted" = "#ff7f0e")  
  ) +
  ylim(0,250) +
  xlim(1980,2021) +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold", size = 14),
    plot.subtitle = element_text(size = 14),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13))
```

```{r, warning=FALSE, message=FALSE, echo= FALSE}

df_forecast_netherlands_auto <- data.frame(
  year = time(forecasted_netherlands_auto$mean),
  mean = exp(forecasted_netherlands_auto$mean),
  lower = exp(forecasted_netherlands_auto$lower[,1]),
  upper = exp(forecasted_netherlands_auto$upper[,1])
)

df_forecast_netherlands_auto

```
Finally, let's see the prediction in the original scale:

```{r, warning=FALSE, message=FALSE, echo= FALSE}

ggplot() +
  geom_line(data = netherlands_data, aes(x = year, y = number_deaths, color = "Actual")) +
  geom_line(data = df_forecast_netherlands_auto, aes(x = year, y = mean, color = "Forecast"), linetype = "dashed") +
  geom_ribbon(data = df_forecast_netherlands_1, aes(x = year, ymin = lower, ymax = upper), alpha = 0.2,fill = "#ff7f0e") +
  scale_color_manual(values = c("Actual" = "#1f77b4", "Forecast" = "#ff7f0e")) +
  labs(title = "TB Death forecast for Netherlands data",
       x = "Year", y = "Number deaths",
       color = "Serie") +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold", size = 16),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13) )

ggplot() +
  geom_line(data = netherlands_data, aes(x = year, y = number_deaths, color = "Actual")) +
  geom_line(data = df_forecast_netherlands_auto, aes(x = year, y = mean, color = "Forecast"), linetype = "dashed") +
  geom_ribbon(data = df_forecast_netherlands_1, aes(x = year, ymin = lower, ymax = upper), alpha = 0.2, fill = "#ff7f0e") +
  scale_color_manual(values = c("Actual" = "#1f77b4", "Forecast" = "#ff7f0e")) +
  labs(title = "TB Death forecast for Netherlands data",
       x = "Year", y = "Number deaths",
       color = "Serie") +
  coord_cartesian(xlim = c(2012, 2024), ylim = c(0,50)) +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold", size = 16),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13) )


```
### Sweden

```{r, warning=FALSE, message=FALSE, echo= FALSE}

sweden_data <- chosen_countries %>% 
  filter(country_name == "Sweden") %>% 
  select(year, number_deaths) %>% 
  arrange(year)

log_sweden_data <- ts(log(sweden_data$number_deaths), start = 1951, frequency = 1)


plot_ts(log_sweden_data) +
  theme_minimal() +
  labs(
    title = "Log-transformed time series of tuberculosis deaths in Sweden",
    x = "Year",
    y = "Log(Number of deaths)"
  ) +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13)
  )

```
In order to determine the ARIMA model order, we need to visualize the ACF and PACF

```{r, warning=FALSE, message=FALSE, echo= FALSE}
par(mfrow = c(2,2))
acf(log_sweden_data) 
pacf(log_sweden_data)
```
Data is clearly non-stationary, so we difference once the time series:

```{r}
log_sweden_data_diff <- log_sweden_data %>% 
  diff(differences = 1)

plot_ts(log_sweden_data_diff)
```
We have stationarized our series; now we need to determine the ARIMA order.

```{r}
acf(log_sweden_data_diff)
pacf(log_sweden_data_diff)
```
Options:
- ARIMA(1,1,0): captures the first order difference and the first lag of the PACF function (model 1).
- ARIMA(0,1,1): captures the first order difference and the first lag of the ACF function (model 2).

We begin the comparison with the first model:

```{r, warning=FALSE, message=FALSE, echo= FALSE}
fit_sweden_model_1 <- arima(log_sweden_data, order = c(1,1,0))
fit_sweden_model_1

```

```{r, warning=FALSE, message=FALSE, echo= FALSE}
fit_sweden_model_1 %>% forecast::checkresiduals()
shapiro.test(residuals(fit_sweden_model_1))
```

Now, to forecast future values, we apply the `forecast()`function:

```{r, warning=FALSE, message=FALSE, echo= FALSE}
forecasted_sweden_model_1 <- forecast(fit_sweden_model_1,level = c(95), h=3, bootstrap = TRUE)

par(mfrow = c(2,2))

autoplot(forecasted_sweden_model_1) +
  theme_minimal() +
  labs(
    title = "Forecasts from ARIMA(1,1,0) for Sweden series",
    x = "Year",
    y = "Log(Number of deaths)"
  ) +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13)
  )

autoplot(forecasted_sweden_model_1) +
  theme_minimal() +
  labs(
    title = "Forecasts from ARIMA(1,1,0) for Sweden series",
    subtitle = "Zoomed-in series (2010-2024)",
    x = "Year",
    y = "Log(Number of deaths)"
  ) +
  xlim(2010,2024) +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    plot.subtitle = element_text(size = 14),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13)
  )
```

Next, we back-transform the forecasts to the original scale by applying the exponential function:

```{r, warning=FALSE, message=FALSE, echo= FALSE}
exp_forecasted_sweden_1_fitted <- exp(forecasted_sweden_model_1$fitted)

sweden_model_1_data <- sweden_data %>% 
  mutate(exp_fitted = exp_forecasted_sweden_1_fitted) 

sweden_model_1_data
```

The fitted values and forecasts are then plotted alongside the original series to assess model performance:

```{r, warning=FALSE, message=FALSE, echo= FALSE}

ggplot(sweden_model_1_data, aes(x = year)) +
  geom_line(aes(y = number_deaths, color = "Actual")) +
  geom_line(aes(y = exp_fitted, color = "Fitted"), linetype = "dashed") +
  scale_color_manual(
    values = c("Actual" = "#1f77b4",  
               "Fitted" = "#ff7f0e")  
  ) +
  labs(title = "Actual vs Fitted TB deaths in Sweden for the ARIMA(1,1,0)",
       x = "Year", y = "Number of Deaths",
       color = "Legend") +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13)
  )

ggplot(sweden_model_1_data, aes(x = year)) +
  geom_line(aes(y = number_deaths, color = "Actual")) +
  geom_line(aes(y = exp_fitted, color = "Fitted"), linetype = "dashed") +
  scale_color_manual(
    values = c("Actual" = "#1f77b4",  
               "Fitted" = "#ff7f0e")  
  ) +
  labs(title = "Actual vs Fitted TB deaths in Sweden",
       subtitle = "Zoomed-in segment of the TB mortality time series in Sweden (1980‚Äì2021)",
       x = "Year", y = "Number of Deaths",
       color = "Legend") +
  ylim(0,300) +
  xlim(1980,2021) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    plot.subtitle = element_text(size = 12),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13)
  )
```

To display the forecasts an their associated uncerainty, we prepare a data frame with the exponential of the forecast and confidence intervals:

```{r, warning=FALSE, message=FALSE, echo= FALSE}

df_forecast_sweden_1 <- data.frame(
  year = time(forecasted_sweden_model_1$mean),
  mean = exp(forecasted_sweden_model_1$mean),
  lower = exp(forecasted_sweden_model_1$lower[,1]),
  upper = exp(forecasted_sweden_model_1$upper[,1])
)

df_forecast_sweden_1

```

Finally, we visualize the forecasts:

```{r, warning=FALSE, message=FALSE, echo= FALSE}

ggplot() +
  geom_line(data = sweden_data, aes(x = year, y = number_deaths, color = "Actual")) +
  geom_line(data = df_forecast_sweden_1, aes(x = year, y = mean, color = "Forecast"), linetype = "dashed") +
  geom_ribbon(data = df_forecast_sweden_1, aes(x = year, ymin = lower, ymax = upper), alpha = 0.2, fill = "#ff7f0e") +
  scale_color_manual(values = c("Actual" = "#1f77b4", "Forecast" = "#ff7f0e")) +
  labs(title = "Forecast for Sweden data",
       subtitle = "Complete series",
       x = "Year", y = "Number deaths",
       color = "Serie") +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold", size = 16),
    plot.subtitle = element_text(size = 12),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13) )


ggplot() +
  geom_line(data = sweden_data, aes(x = year, y = number_deaths, color = "Actual")) +
  geom_line(data = df_forecast_sweden_1, aes(x = year, y = mean, color = "Forecast"), linetype = "dashed") +
  geom_ribbon(data = df_forecast_sweden_1, aes(x = year, ymin = lower, ymax = upper), alpha = 0.2, fill = "#ff7f0e") +
  scale_color_manual(values = c("Actual" = "#1f77b4", "Forecast" = "#ff7f0e")) +
  labs(title = "TB Death forecast for Sweden data",
       subtitle = "Zoomed-in forecast (2012-2024)",
       x = "Year", y = "Number deaths",
       color = "Serie") +
  coord_cartesian(xlim = c(2012, 2024), ylim = c(0,50)) +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold", size = 16),
    plot.subtitle = element_text(size = 12),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13) )


```
Now, let's study the second model:

```{r, warning=FALSE, message=FALSE, echo= FALSE}

fit_sweden_model_2 <- forecast::auto.arima(log_sweden_data)
fit_sweden_model_2
```

```{r, warning=FALSE, message=FALSE, echo= FALSE}
fit_sweden_model_2 %>% forecast::checkresiduals()
shapiro.test(residuals(fit_sweden_model_2))
```

Now, to forecast future values, we apply the `forecast()`function:

```{r, warning=FALSE, message=FALSE, echo= FALSE}
forecasted_sweden_model_2 <- forecast(fit_sweden_model_2,level = c(95), h=3, bootstrap = TRUE)
forecasted_sweden_model_2

par(mfrow = c(2,2))

autoplot(forecasted_sweden_model_2) +
  theme_minimal() +
  labs(
    title = "Forecasts from ARIMA(0,1,1) for Sweden series",
    x = "Year",
    y = "Log(Number of deaths)"
  ) +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13)
  )

autoplot(forecasted_sweden_model_2) +
  theme_minimal() +
  labs(
    title = "Forecasts from ARIMA(0,1,1) for Sweden series",
    subtitle = "Zoomed-in series (2010-2024)",
    x = "Year",
    y = "Log(Number of deaths)"
  ) +
  xlim(2010,2024) +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    plot.subtitle = element_text(size = 14),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13)
  )
```

Next, we back-transform the forecasts to the original scale by applying the exponential function:

```{r, warning=FALSE, message=FALSE, echo= FALSE}
exp_forecasted_sweden_2_fitted <- exp(forecasted_sweden_model_2$fitted)

sweden_model_2_data <- sweden_data %>% 
  mutate(exp_fitted = exp_forecasted_sweden_2_fitted) 

sweden_model_2_data
```

The fitted values and forecasts are then plotted alongside the original series to assess model performance:

```{r, warning=FALSE, message=FALSE, echo= FALSE}

ggplot(sweden_model_2_data, aes(x = year)) +
  geom_line(aes(y = number_deaths, color = "Actual")) +
  geom_line(aes(y = exp_fitted, color = "Fitted"), linetype = "dashed") +
  scale_color_manual(
    values = c("Actual" = "#1f77b4",  
               "Fitted" = "#ff7f0e")  
  ) +
  labs(title = "Actual vs Fitted TB deaths in Sweden for the ARIMA(0,1,1)",
       x = "Year", y = "Number of Deaths",
       color = "Legend") +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13)
  )

ggplot(sweden_model_2_data, aes(x = year)) +
  geom_line(aes(y = number_deaths, color = "Actual")) +
  geom_line(aes(y = exp_fitted, color = "Fitted"), linetype = "dashed") +
  scale_color_manual(
    values = c("Actual" = "#1f77b4",  
               "Fitted" = "#ff7f0e")  
  ) +
  labs(title = "Actual vs Fitted TB deaths in Sweden for the ARIMA(0,1,1)",
       subtitle = "Zoomed-in segment of the TB mortality time series in Sweden (1980‚Äì2021)",
       x = "Year", y = "Number of Deaths",
       color = "Legend") +
  ylim(0,300) +
  xlim(1980,2021) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    plot.subtitle = element_text(size = 12),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13)
  )
```

To display the forecasts an their associated uncerainty, we prepare a data frame with the exponential of the forecast and confidence intervals:

```{r, warning=FALSE, message=FALSE, echo= FALSE}

df_forecast_sweden_2 <- data.frame(
  year = time(forecasted_sweden_model_2$mean),
  mean = exp(forecasted_sweden_model_2$mean),
  lower = exp(forecasted_sweden_model_2$lower[,1]),
  upper = exp(forecasted_sweden_model_2$upper[,1])
)

df_forecast_sweden_2

```

Finally, we visualize the forecasts:

```{r, warning=FALSE, message=FALSE, echo= FALSE}

ggplot() +
  geom_line(data = sweden_data, aes(x = year, y = number_deaths, color = "Actual")) +
  geom_line(data = df_forecast_sweden_2, aes(x = year, y = mean, color = "Forecast"), linetype = "dashed") +
  geom_ribbon(data = df_forecast_sweden_2, aes(x = year, ymin = lower, ymax = upper), alpha = 0.2, fill = "#ff7f0e") +
  scale_color_manual(values = c("Actual" = "#1f77b4", "Forecast" = "#ff7f0e")) +
  labs(title = "Forecast for Sweden data",
       subtitle = "Complete series",
       x = "Year", y = "Number deaths",
       color = "Serie") +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold", size = 16),
    plot.subtitle = element_text(size = 12),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13) )


ggplot() +
  geom_line(data = sweden_data, aes(x = year, y = number_deaths, color = "Actual")) +
  geom_line(data = df_forecast_sweden_2, aes(x = year, y = mean, color = "Forecast"), linetype = "dashed") +
  geom_ribbon(data = df_forecast_sweden_2, aes(x = year, ymin = lower, ymax = upper), alpha = 0.2, fill = "#ff7f0e") +
  scale_color_manual(values = c("Actual" = "#1f77b4", "Forecast" = "#ff7f0e")) +
  labs(title = "TB Death forecast for Sweden data",
       subtitle = "Zoomed-in forecast (2012-2024)",
       x = "Year", y = "Number deaths",
       color = "Serie") +
  coord_cartesian(xlim = c(2012, 2024), ylim = c(0,50)) +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold", size = 16),
    plot.subtitle = element_text(size = 12),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13) )


```


### Switzerland

```{r, warning=FALSE, message=FALSE, echo= FALSE}
switzerland_data <- chosen_countries %>% 
  filter(country_name == "Switzerland") %>% 
  select(year, number_deaths) %>% 
  arrange(year)

log_switzerland_data = ts(log(switzerland_data$number_deaths), start = 1951, frequency = 1)

plot_ts(log_switzerland_data) +   
  theme_minimal() +
  labs(
    title = "Log-transformed time series of tuberculosis deaths in Switzerland",
    x = "Year",
    y = "Number of deaths"
  ) +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13)
  )

```



```{r}
plot_ts(log_switzerland_data %>% diff(differences = 1))
forecast::auto.arima(log_switzerland_data)
```



### Romania
 
We begin now the study for Romania data; remember that this series does not present a strong exponential trend as the previous countries, so the analysis should differ. We begin by plotting the time series:

```{r}
romania_data <- chosen_countries %>% 
  filter(country_name == "Romania") %>% 
  select(year, number_deaths) %>% 
  arrange(year) #1959-2019

romania_ts <- ts(romania_data$number_deaths, start = 1959, frequency = 1)
plot_ts(romania_ts) +   
  theme_minimal() +
  labs(
    title = "Time series of tuberculosis deaths in Romania",
    x = "Year",
    y = "Number of deaths"
  ) +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13)
  )

```
We see that it has a strong decreasing trend until 1980, and from that year onward it begins to rise again until 2000, when it starts to decline definitively. 

```{r}
#par(mfrow = c(2,2))
acf(romania_ts)
pacf(romania_ts)

```
The ACF shows strong autocorrelation between lags; let us apply a first order difference.

```{r}
romania_ts_diff <- romania_ts %>% diff(differences = 1)
plot_ts(romania_ts_diff )

```
It seems to not be stationary, so we can difference twice:

```{r}
romania_ts_diff_2 <- romania_ts %>% diff(differences = 2)
plot_ts(romania_ts_diff_2)

acf(romania_ts_diff_2)
pacf(romania_ts_diff_2)
```

## Train / Test
### Spain

```{r}
# We divide the logarithmic datset into training and testing datasets.

log_spain_data_train <- ts(log_spain_data[0:60], start = 1951, frequency = 1)
log_spain_data_test <- ts(log_spain_data[61:71], start = 2011, frequency = 1)

plot_ts(log_spain_data_train) +
  theme_minimal() +
  labs(
    title = "Log-transformed time series of tuberculosis deaths in Spain",
    x = "Year",
    y = "Log(Number of deaths)"
  ) +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13)
  )
```
It is clear that the training set is not stationary; a solution could be differencing the series.

```{r, warning=FALSE}
log_spain_data_train_diff <- log_spain_data_train %>% diff(differences = 1)

df_spain <- data.frame(
  year = as.numeric(time(log_spain_data_train_diff)),
  value = as.numeric(log_spain_data_train_diff)
)

df_lm <- df_spain[-c(1, 2), ]

plot_ts(log_spain_data_train_diff) +
  geom_smooth(method = "lm", se = TRUE, color = "steelblue", linetype = "dashed") +
  theme_minimal() +
  labs(
    title = " ",
    x = "Year",
    y = " "
  ) +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13)
  )



ggplot(df, aes(x = year, y = value)) +
  geom_point(color = "black") +                            
  geom_smooth(data = df_lm, method = "lm", se = FALSE,        
              color = "steelblue", linetype = "dashed") +
  theme_minimal() +
  labs(
    title = " ",
    x = "Year",
    y = " "
  ) +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13)
  )



```
Although the series may initially appear stationary in the plot, the scatter pattern suggests otherwise. To assess this formally, we apply the KPSS test to the differenced series:

```{r}
kpss.test(log_spain_data_train_diff)
```

The p-value obtained is $0.03468$. Therefore, we reject the null hypothesis of stationarity. This indicates that the differenced series is still not stationary, and a second-order difference is required.

```{r}
log_spain_data_train_diff <- log_spain_data_train %>% 
  diff(differences = 2)

plot_ts(log_spain_data_train_diff) +
  #geom_smooth(method = "lm", se = TRUE, color = "steelblue", linetype = "dashed") +
  theme_minimal() +
  labs(
    title = " ",
    x = "Year",
    y = " "
  ) +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13)
  )
```
We check the new differenced time series:

```{r}
kpss.test(log_spain_data_train_diff)
```
The p-value now is greater than $0.05$, so we guarenteed the stationarity. Now, let's check the ACF and PACF plots.

```{r}
par(mfrow = c(2,2))
acf(log_spain_data_train_diff) 
pacf(log_spain_data_train_diff)

```

Based on the two previous plots, we have to determine the orders for the ARIMA models. We would do the selection sistematically, meaning that we will choose the two best models (in terms of AIC value) out of all possible options.


```{r}
ma_coef <- c(0,1,2)
ar_coef <- c(0,1)

for (p in ar_coef) {
  for (q in ma_coef) {
    arima_fit <- arima(log_spain_data_train, order = c(p, 2, q))
    cat("ARIMA(", p, ",2,", q, ")\n", sep = "")
    print(arima_fit$coef)
    cat("AIC:", AIC(arima_fit), "\n\n")
  }
}


```
We will study the following models:

- ARIMA(0,2,1)
- ARIMA(1,2,1)

#### First model: ARIMA(0,2,1)

Let's check the first model:

```{r}
fit_spain_1 <- Arima(log_spain_data_train, order = c(0,2,1))
summary(fit_spain_1)
```
Now the residuals of the first model:

```{r}
fit_spain_1 %>% forecast::checkresiduals()

shapiro.test(residuals(fit_spain_1))
```
The Ljung-Box test determines that the residuals of the model do not present autocorrelation. As so, the Shapiro-Wilk test determines that the residuals are approximately normally distributed. This means that the model satisfies the residuals considerations.

We begin the forecast; we will forecast the testing dataset values.

```{r}
horizon_spain <- length(log_spain_data_test)

forecasted_spain_1 <- forecast(fit_spain_1, h=horizon_spain, level = c(95),bootstrap = FALSE)
forecasted_spain_1

```

If we compared the predicted logarithmic points versus the original logarithmic points:

```{r}
predicted_spain_1 <- forecasted_spain_1$mean
actual_spain <- log_spain_data_test

test_log_spain_model_1 <- data.frame(
  year = 2011:2021,
  actual = actual_spain,
  predicted = predicted_spain_1,
  diff = abs(actual_spain - predicted_spain_1)
)

test_log_spain_model_1
```

We can plot the results:


```{r}
ggplot(test_log_spain_model_1, aes(x = year)) +
  geom_line(aes(y = actual, color = "Actual")) +
  geom_line(aes(y = predicted, color = "Predicted"), linetype = "dashed") +
  scale_color_manual(values = c("Actual" = "#1f77b4", "Predicted" = "#ff7f0e")) +
  labs(title = " Logarithmic TB deaths in Spain: Actual vs Predicted (2012‚Äì2021)",
       x = "Year", y = "Number of Deaths", color = "Legend") +
  theme_minimal()
```
It is clear that the forecasted points do not modelize correctly the original logarithmic data. The forecast for the original data can be seen in the following plot:

```{r}
predicted_original_spain_1 <- exp(predicted_spain_1)
actual_original_spain <- exp(actual_spain)


test_spain_model_1 <- data.frame(
  year = 2011:2021,
  actual = actual_original_spain,
  predicted = predicted_original_spain_1
)

test_spain_model_1 %>% 
  mutate(diff = abs(actual -predicted))

ggplot(test_spain_model_1, aes(x = year)) +
  geom_line(aes(y = actual, color = "Actual")) +
  geom_line(aes(y = predicted, color = "Predicted"), linetype = "dashed") +
  scale_color_manual(values = c("Actual" = "#1f77b4", "Predicted" = "#ff7f0e")) +
  labs(title = "TB Deaths in Spain: Actual vs Predicted (2012‚Äì2021)",
       x = "Year", y = "Number of Deaths", color = "Legend") +
  theme_minimal()
```
Finally, let's check the accuracy of the model:

```{r}
accuracy(predicted_original_spain_1, actual_original_spain)
```



#### Second model: ARIMA(1,2,1)

We study now the second model.

```{r}
fit_spain_2 <- Arima(log_spain_data_train, order = c(1,2,1))
summary(fit_spain_2)

```
We analyze the residuals of the model:

```{r}
fit_spain_2 %>% 
  forecast::checkresiduals()

shapiro.test(residuals(fit_spain_2))
```
The Ljung-Box test allows to ensure that the residuals do not present any correlation. Moreover, the residuals also pass the Shapiro-Wilk test, meaning that they ditribute normally. Now, let's see the forecast on the testing dataset.

```{r}
forecasted_spain_2 <- forecast(fit_spain_2, h=horizon_spain, level=c(95), bootstrap = TRUE)
forecasted_spain_2
```

Let's compare the forecasted values and the actual ones:

```{r}

predicted_spain_2 <- forecasted_spain_2$mean
actual_spain <- log_spain_data_test

test_log_spain_model_2 <- data.frame(
  year = 2011:2021,
  actual = actual_spain,
  predicted = predicted_spain_2,
  diff = abs(predicted_spain_2 - actual_spain)
)

test_log_spain_model_2

```
We can plot the results:


```{r}
ggplot(test_log_spain_model_2, aes(x = year)) +
  geom_line(aes(y = actual, color = "Actual")) +
  geom_line(aes(y = predicted, color = "Predicted"), linetype = "dashed") +
  scale_color_manual(values = c("Actual" = "#1f77b4", "Predicted" = "#ff7f0e")) +
  labs(title = " Logarithmic TB deaths in Spain: Actual vs Predicted (2012‚Äì2021)",
       x = "Year", y = "Number of Deaths", color = "Legend") +
  theme_minimal()
```
```{r}

predicted_original_spain_2 <- exp(predicted_spain_2)
actual_original_spain <- exp(actual_spain)

```

We can see the forecasted points using the orginial scale:

```{r}
test_spain_model_2 <- data.frame(
  year = 2011:2021,
  actual = actual_original_spain,
  predicted = predicted_original_spain_2
)

test_spain_model_2 %>% 
  mutate(diff = abs(actual -predicted))

ggplot(test_spain_model_2, aes(x = year)) +
  geom_line(aes(y = actual, color = "Actual")) +
  geom_line(aes(y = predicted, color = "Predicted"), linetype = "dashed") +
  scale_color_manual(values = c("Actual" = "#1f77b4", "Predicted" = "#ff7f0e")) +
  labs(title = "TB Deaths in Spain: Actual vs Predicted (2012‚Äì2021)",
       x = "Year", y = "Number of Deaths", color = "Legend") +
  theme_minimal()

```
Finally, let's check the accuracy of the model:

```{r}
accuracy(predicted_original_spain_2, actual_original_spain)

```


### Netherlands

We can do the same with Netherlands data.

```{r}
netherlands_data <- chosen_countries %>% 
  filter(country_name == "Netherlands") %>% 
  select(year, number_deaths) %>% 
  arrange(year)

max(netherlands_data$year)

log_netherlands_data <- ts(log(netherlands_data$number_deaths), start = c(1950), frequency = 1)

log_neth_data_train <- ts(log_netherlands_data[0:62], start = 1950, frequency = 1)
log_neth_data_test <- ts(log_netherlands_data[63:73], start = 2012, frequency = 1)

plot_ts(log_neth_data_train) +
  theme_minimal() +
  labs(
    title = "Log-transformed time series of tuberculosis deaths in Netherlands",
    x = "Year",
    y = "Log(Number of deaths)"
  ) +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13)
  )
```
We try now to remove the trend of the time series.

```{r}
log_neth_data_train_diff <- log_neth_data_train %>% diff(differences = 1) 

plot_ts(log_neth_data_train_diff)+
  theme_minimal()
```
We apply the KPSS test to ensure stationarity:

```{r}
kpss.test(log_neth_data_train_diff)
```
The p-value is bigger than 0,05, so the time series is now stationary.

Now let's check the ACF and PACF plots:

```{r}
acf(log_neth_data_train_diff)
pacf(log_neth_data_train_diff)
```
Let's select the two best models, following the same schema as in Spain data.

```{r}
ar_coef <- c(0,1,2,3)
ma_coef <- c(0,1,2,3)

for (p in ar_coef) {
  for (q in ma_coef) {
    arima_fit <- arima(log_neth_data_train, order = c(p, 1, q))
    cat("ARIMA(", p, ",1,", q, ")\n", sep = "")
    print(arima_fit$coef)
    cat("AIC:", AIC(arima_fit), "\n\n")
  }
}
```
The ARIMA models selected for the study are:

- ARIMA(1,1,3)
- ARIMA(3,1,3)

#### First model: ARIMA(1,1,3)

```{r}
fit_neth_1 <- Arima(log_neth_data_train, order = c(1,1,3))
summary(fit_neth_1)
```
Let's check the residuals of the model:

```{r}
fit_neth_1 %>% forecast::checkresiduals()
shapiro.test(residuals(fit_neth_1))
```
The residuals tests from above determine that the residuals present no correlation, but they do not distribute normally. The negative effect this can produce to the forecast will be controlled with the bootstrap attribute.

Let's forecast

```{r}
horizon_neth <- length(log_neth_data_test)
forecasted_neth_1 <- forecast(fit_neth_1, h=horizon_neth, level = c(95), bootstrap = TRUE)
forecasted_neth_1
```
If we compare the predicted logarithmic points versus the original logarithmic points:

```{r}
predicted_neth_1 <- forecasted_neth_1$mean

test_log_neth_model_1 <- data.frame(
  year = 2011:2021,
  actual = log_neth_data_test,
  predicted = predicted_neth_1,
  diff = abs(log_neth_data_test - predicted_neth_1)
)

test_log_neth_model_1
```

We can plot the results:

```{r}
ggplot(test_log_neth_model_1, aes(x = year)) +
  geom_line(aes(y = actual, color = "Actual")) +
  geom_line(aes(y = predicted, color = "Predicted"), linetype = "dashed") +
  scale_color_manual(values = c("Actual" = "#1f77b4", "Predicted" = "#ff7f0e")) +
  labs(title = " Logarithmic TB deaths in Netherland: Actual vs Predicted (2012‚Äì2021)",
       x = "Year", y = "Number of Deaths", color = "Legend") +
  theme_minimal()
```
The forecast for the original data can be seen in the following plot:

```{r}

predicted_original_neth_1 <- exp(predicted_neth_1)
actual_original_neth <- exp(log_neth_data_test)


test_original_neth_model_1 <- data.frame(
  year = 2011:2021,
  actual = actual_original_neth,
  predicted = predicted_original_neth_1
)

test_original_neth_model_1 %>% 
  mutate(diff = abs(actual -predicted))

ggplot(test_original_neth_model_1, aes(x = year)) +
  geom_line(aes(y = actual, color = "Actual")) +
  geom_line(aes(y = predicted, color = "Predicted"), linetype = "dashed") +
  scale_color_manual(values = c("Actual" = "#1f77b4", "Predicted" = "#ff7f0e")) +
  labs(title = "TB Deaths in the Netherlands: Actual vs Predicted (2012‚Äì2021)",
       x = "Year", y = "Number of Deaths", color = "Legend") +
  theme_minimal()
```

Finally, we need to check the accuracy of the model:

```{r}
accuracy(predicted_original_neth_1, actual_original_neth)
```

#### Second model: ARIMA(3,1,3)

```{r}
fit_neth_2 <- Arima(log_neth_data_train, order = c(3,1,3))
summary(fit_neth_2)
```
Let's check the residuals of the model:


```{r}
fit_neth_2 %>% forecast::checkresiduals()
shapiro.test(residuals(fit_neth_2))
```

As the previous model, the residuals present no correlation, and they do not follow a normal distribution.

```{r}
forecasted_neth_2 <- forecast(fit_neth_2, h = horizon_neth, level = c(95), bootstrap = TRUE)
forecasted_neth_2
```
If we compare the predicted logarithmic points versus the original logarithmic points:

```{r}
predicted_neth_2 <- forecasted_neth_2$mean

test_log_neth_model_2 <- data.frame(
  year = 2011:2021,
  actual = log_neth_data_test,
  predicted = predicted_neth_2,
  diff = abs(log_neth_data_test - predicted_neth_2)
)

test_log_neth_model_2
```

We can plot the results:

```{r}
ggplot(test_log_neth_model_2, aes(x = year)) +
  geom_line(aes(y = actual, color = "Actual")) +
  geom_line(aes(y = predicted, color = "Predicted"), linetype = "dashed") +
  scale_color_manual(values = c("Actual" = "#1f77b4", "Predicted" = "#ff7f0e")) +
  labs(title = " Logarithmic TB deaths in Netherland: Actual vs Predicted (2012‚Äì2021)",
       x = "Year", y = "Number of Deaths", color = "Legend") +
  theme_minimal()
```
The forecast for the original data can be seen in the following plot:

```{r}

predicted_original_neth_2 <- exp(predicted_neth_2)
actual_original_neth <- exp(log_neth_data_test)


test_original_neth_model_2 <- data.frame(
  year = 2011:2021,
  actual = actual_original_neth,
  predicted = predicted_original_neth_2
)

test_original_neth_model_2 %>% 
  mutate(diff = abs(actual -predicted))

ggplot(test_original_neth_model_2, aes(x = year)) +
  geom_line(aes(y = actual, color = "Actual")) +
  geom_line(aes(y = predicted, color = "Predicted"), linetype = "dashed") +
  scale_color_manual(values = c("Actual" = "#1f77b4", "Predicted" = "#ff7f0e")) +
  labs(title = "TB Deaths in the Netherlands: Actual vs Predicted (2012‚Äì2021)",
       x = "Year", y = "Number of Deaths", color = "Legend") +
  theme_minimal()
```

Finally, we need to check the accuracy of the model:

```{r}
accuracy(predicted_original_neth_2, actual_original_neth)
```


### Sweden

We begin the Sweden data study.

```{r}
sweden_data <- chosen_countries %>% 
  filter(country_name == "Sweden") %>% 
  select(year, number_deaths) %>% 
  arrange(year)

log_sweden_data <- ts(log(sweden_data$number_deaths), start = c(1951), frequency = 1)

log_sweden_data_train <- ts(log_sweden_data[0:62], start = 1951, frequency = 1)
log_sweden_data_test <- ts(log_sweden_data[63:72], start = 2013, frequency = 1)

plot_ts(log_sweden_data_train) +
  theme_minimal() +
  labs(
    title = "Log-transformed time series of tuberculosis deaths in Sweden",
    x = "Year",
    y = "Log(Number of deaths)"
  ) +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13)
  )
```
We try now to remove the trend of the time series.

```{r}
log_sweden_data_train_diff <- log_sweden_data_train %>% diff(differences = 1) 

plot_ts(log_sweden_data_train_diff)+
  theme_minimal()
```
We apply the KPSS test to ensure stationarity:

```{r}
kpss.test(log_sweden_data_train_diff)
```
Now let's check the ACF and PACF plots:

```{r}
acf(log_sweden_data_train_diff)
pacf(log_sweden_data_train_diff)
```
Let's select the two best models, following the same schema as in Spain data.

```{r}
ar_coef <- c(0,1)
ma_coef <- c(0,1)

for (p in ar_coef) {
  for (q in ma_coef) {
    arima_fit <- arima(log_sweden_data_train, order = c(p, 1, q))
    cat("ARIMA(", p, ",1,", q, ")\n", sep = "")
    print(arima_fit$coef)
    cat("AIC:", AIC(arima_fit), "\n\n")
  }
}
```
The ARIMA models selected for the study are:

- ARIMA(0,1,0)
- ARIMA(1,1,1)

#### First model: ARIMA(0,1,0)

```{r}
fit_sweden_1 <- Arima(log_sweden_data_train, order = c(0,1,0))
summary(fit_sweden_1)
```
Let's check the residuals of the model:

```{r}
fit_sweden_1 %>% forecast::checkresiduals()
shapiro.test(residuals(fit_sweden_1))
```
Notice that the residuals for this model do not pass any of the tests: Ljung-Box, meaning that they still capture some correlation between lags, and neither the Shapiro-Wilk test, meaning that they do not distribute normally. Basing on this results, the best option is to select another order for the ARIMA models. We will study the ARIMA(1,1,0).

```{r}
fit_sweden_1 <- Arima(log_sweden_data_train, order = c(1,1,0))
summary(fit_sweden_1)
```
Let's analyze the residuals of the test:

```{r}
fit_sweden_1 %>% forecast::checkresiduals()
shapiro.test(residuals(fit_sweden_1))
```

The residuals tests from above determine that the residuals present no correlation, but they do not distribute normally. The negative effect this can produce to the forecast will be controlled with the bootstrap attribute.

Let's forecast:

```{r}
horizon_sweden <- length(log_sweden_data_test)
forecasted_sweden_1 <- forecast(fit_sweden_1, h=horizon_sweden, level = c(95), bootstrap = TRUE)
forecasted_sweden_1
```
Notice that from 2025 towards, the forecasted points are all the same. 

If we compare the predicted logarithmic points versus the original logarithmic points:

```{r}
predicted_sweden_1 <- forecasted_sweden_1$mean

test_log_sweden_model_1 <- data.frame(
  year = 2013:2022,
  actual = log_sweden_data_test,
  predicted = predicted_sweden_1,
  diff = abs(log_sweden_data_test - predicted_sweden_1)
)

test_log_sweden_model_1
```

We can plot the results:

```{r}
ggplot(test_log_sweden_model_1, aes(x = year)) +
  geom_line(aes(y = actual, color = "Actual")) +
  geom_line(aes(y = predicted, color = "Predicted"), linetype = "dashed") +
  scale_color_manual(values = c("Actual" = "#1f77b4", "Predicted" = "#ff7f0e")) +
  labs(title = " Logarithmic TB deaths in Sweden: Actual vs Predicted (2012‚Äì2021)",
       x = "Year", y = "Number of Deaths", color = "Legend") +
  theme_minimal()
```

It is clear that the forecasted points do not predict correctly the future values. However, let's see the forecast in the original scale of the data:

```{r}

predicted_original_sweden_1 <- exp(predicted_sweden_1)
actual_original_sweden <- exp(log_sweden_data_test)


test_original_sweden_model_1 <- data.frame(
  year = 2013:2022,
  actual = actual_original_sweden,
  predicted = predicted_original_sweden_1
)

test_original_sweden_model_1 %>% 
  mutate(diff = abs(actual -predicted))

ggplot(test_original_sweden_model_1, aes(x = year)) +
  geom_line(aes(y = actual, color = "Actual")) +
  geom_line(aes(y = predicted, color = "Predicted"), linetype = "dashed") +
  scale_color_manual(values = c("Actual" = "#1f77b4", "Predicted" = "#ff7f0e")) +
  labs(title = "TB Deaths in Sweden: Actual vs Predicted (2012‚Äì2021)",
       x = "Year", y = "Number of Deaths", color = "Legend") +
  theme_minimal()
```

Finally, we need to check the accuracy of the model:

```{r}
accuracy(predicted_original_sweden_1, actual_original_sweden)
```

#### Second model: ARIMA(1,1,1)

```{r}
fit_sweden_2 <- Arima(log_sweden_data_train, order = c(1,1,1))
summary(fit_sweden_2)
```

Let's check the residuals:

```{r}
fit_sweden_2 %>% forecast::checkresiduals()
shapiro.test(residuals(fit_sweden_2))
```

The residuals for the model still present autocorrelation and do not follow a normal distribution; in this case, we are going to change the order of the model again. The model proposed is an ARIMA(0,1,1):

```{r}
fit_sweden_2 <- Arima(log_sweden_data_train, order = c(0,1,1))
summary(fit_sweden_2)
```

Now, let's check the residuals of the model:

```{r}
fit_sweden_2 %>% forecast::checkresiduals()
shapiro.test(residuals(fit_sweden_2))
```

The residuals do not pass the Shapiro-Wilk normality test (p-value = $0.049$); however, the model has no correlation left in the residuals.

We can now forecast:

```{r}
forecasted_sweden_2 <- forecast(fit_sweden_2, h = horizon_sweden, level = c(95), bootstrap = TRUE)
forecasted_sweden_2
```
The model do not forecast well. We will study another type of models for Sweden forecast.

### Switzerland


```{r}
switzerland_data <- chosen_countries %>% 
  filter(country_name == "Switzerland") %>% 
  select(year, number_deaths) %>% 
  arrange(year)

log_switzerland_data = ts(log(switzerland_data$number_deaths), start = 1951, frequency = 1)
plot_ts(log_switzerland_data) +   
  theme_minimal() +
  labs(
    title = "Log-transformed time series of tuberculosis deaths in Switzerland",
    x = "Year",
    y = "Number of deaths"
  ) +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13)
  )

```
We divide the data into a training set and a testing set:

```{r}
log_switz_train <- ts(log_switzerland_data[0:60], start = 1951, frequency = 1)
log_switz_test <- ts(log_switzerland_data[61:71], start = 2011, frequency = 1)
```
As seen, the time series is not stationary, so we need to difference the series:

```{r}
log_switz_train_diff <- log_switz_train %>% diff()
plot_ts(log_switz_train_diff) +
  theme_minimal()
kpss.test(log_switz_train_diff)
```
With just one difference, the logarithmic data of Switzerland passes the stationary test. Let's check the ACF and PACF plots:

```{r}
acf(log_switz_train_diff)
pacf(log_switz_train_diff)
```
The differenced time series does not present any correlation left, so the model that we will apply is just ARIMA(0,1,0).

```{r}
fit_switz <- Arima(log_switz_train, order = c(0,1,0))
summary(fit_switz)
```
Now, let's check the residuals:

```{r}
fit_switz %>% forecast::checkresiduals()
shapiro.test(residuals(fit_switz))
```
The residuals seem to not pass the Shapiro-Wilk test. Now, let's forecast:

```{r}
horizon_switz <- length(log_switz_test)
forecasted_switz <- forecast(fit_switz, h = horizon_switz, level = c(95), bootstrap = TRUE)
forecasted_switz
```
Well, the model do not predict correctly the future values. 

### Romania

Now, let's study Romania data.

```{r}
romania_data <- chosen_countries %>% 
  filter(country_name == "Romania") %>% 
  select(year, number_deaths) %>% 
  arrange(year) 


romania_ts <- ts(romania_data$number_deaths, start = 1959, frequency = 1)
plot_ts(romania_ts) +   
  theme_minimal() +
  labs(
    title = "Time series of tuberculosis deaths in Romania",
    x = "Year",
    y = "Number of deaths"
  ) +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13)
  )
```

This data is a bit different from the rest, as it do not present a monotone decaying trend. Let's try to convert the series into a stationary series.

```{r}
romania_train <- ts(romania_ts[0:50], start = 1959, frequency = 1)
romania_test <- ts(romania_ts[50:60], start = 2009, frequency = 1)


```

```{r}
romania_train_diff <- romania_train %>% diff(differences = 2)
kpss.test(romania_train_diff)


plot_ts(romania_train_diff) + 
  theme_minimal()
```
Let's check the ACF and PACF plots:

```{r}
acf(romania_train_diff)
pacf(romania_train_diff)
```
```{r}
ma_coef <- c(0,2)
ar_coef <- c(0,2)

for (p in ar_coef) {
  for (q in ma_coef) {
    arima_fit <- Arima(romania_train, order = c(p, 2, q))
    cat("ARIMA(", p, ",2,", q, ")\n", sep = "")
    print(arima_fit$coef)
    cat("AIC:", AIC(arima_fit), "\n\n")
  }
}
```
We will study: 
- ARIMA(0,2,2)
- ARIMA(2,2,0)

#### First model: ARIMA(0,2,2)

```{r}
fit_romania_1 <- Arima(romania_train, order = c(0,2,2))
fit_romania_1
```
The residuals of the series:

```{r}
fit_romania_1 %>%  forecast::checkresiduals()
shapiro.test(residuals(fit_romania_1))
```

Now, let's forecast:

```{r}
horizon_romania <- length(romania_test)
forecasted_romania_1 <- forecast(fit_romania_1, h = horizon_romania, level = c(95), bootstrap = TRUE)
forecasted_romania_1
```
If we compare the predicted logarithmic points versus the original logarithmic points:

```{r}
predicted_romania_1 <- forecasted_romania_1$mean

test_romania_1 <- data.frame(
  year = 2009:2019,
  actual = romania_test,
  predicted = predicted_romania_1,
  diff = abs(romania_test - predicted_romania_1)
)

test_romania_1
```

We can plot the results:

```{r}
ggplot(test_romania_1, aes(x = year)) +
  geom_line(aes(y = actual, color = "Actual")) +
  geom_line(aes(y = predicted, color = "Predicted"), linetype = "dashed") +
  scale_color_manual(values = c("Actual" = "#1f77b4", "Predicted" = "#ff7f0e")) +
  labs(title = " Logarithmic TB deaths in Romania: Actual vs Predicted (2012‚Äì2021)",
       x = "Year", y = "Number of Deaths", color = "Legend") +
  theme_minimal()
```
It seems to have cached the decaying trend. Finally, we check the accuracy of the test:

```{r}
accuracy(predicted_romania_1, romania_test)
```

#### Second model: ARIMA(2,2,0)

```{r}
fit_romania_2 <- Arima(romania_train, order = c(2,2,0))
fit_romania_2
```

```{r}
fit_romania_2 %>% forecast::checkresiduals()
shapiro.test(residuals(fit_romania_2))
```

The residuals pass the two important tests. Let's forecast:

```{r}
forecasted_romania_2 <- forecast(fit_romania_2, h = horizon_romania, level = c(95), bootstrap = FALSE)
forecasted_romania_2
```

Now, we can compare the results:

```{r}
predicted_romania_2 <- forecasted_romania_1$mean

test_romania_2 <- data.frame(
  year = 2009:2019,
  actual = romania_test,
  predicted = predicted_romania_2,
  diff = abs(romania_test - predicted_romania_2)
)

test_romania_2
```

We can plot the results:

```{r}
ggplot(test_romania_2, aes(x = year)) +
  geom_line(aes(y = actual, color = "Actual")) +
  geom_line(aes(y = predicted, color = "Predicted"), linetype = "dashed") +
  scale_color_manual(values = c("Actual" = "#1f77b4", "Predicted" = "#ff7f0e")) +
  labs(title = " Logarithmic TB deaths in Romania: Actual vs Predicted (2012‚Äì2021)",
       x = "Year", y = "Number of Deaths", color = "Legend") +
  theme_minimal()
```
Finally, let's check the accuracy of the model:

```{r}
accuracy(predicted_romania_2, romania_test)
```

### Latvia

Finally, we are goinf to study Latvia data.

```{r}
latvia_data <-chosen_countries %>% 
  filter(country_name == "Latvia") %>% 
  select(year, number_deaths) %>% 
  arrange(year) 

latvia_ts <- ts(latvia_data$number_deaths, start = 1980, frequency = 1)
plot_ts(latvia_ts) +   
  theme_minimal() +
  labs(
    title = "Time series of tuberculosis deaths in Latvia",
    x = "Year",
    y = "Number of deaths"
  ) +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 13)
  )
```
```{r}
latvia_train <- ts(latvia_ts[0:30], start = 1980, frequency = 1)
latvia_test <- ts(latvia_ts[30:41], start = 2011, frequency = 1)

```

Let's plot Latvia train set:

```{r}
plot_ts(latvia_train) +
  theme_minimal()
```

It is clearly non-stationary. We need to difference the time series.

```{r}
latvia_train_diff <- latvia_train %>% diff()
plot_ts(latvia_train_diff) +
  theme_minimal()

kpss.test(latvia_train_diff)
```

We only need a first order difference to get the series stationary. Now, let's study the ACF and PACF plots:

```{r}
acf(latvia_train_diff)
pacf(latvia_train_diff)
```
The model that we can apply is ARIMA(0,1,0).

```{r}
fit_latvia <- Arima(latvia_train, order = c(0,1,0))
summary(fit_latvia)
```

We need to study the residuals:

```{r}
fit_latvia %>% forecast::checkresiduals()
shapiro.test(residuals(fit_latvia))
```

Finally, let's forecast:

```{r}
horizon_latvia <- length(latvia_test)
forecasted_latvia <- forecast(fit_latvia, h = horizon_latvia, level = c(95), bootstrap = FALSE)
forecasted_latvia
```
Well, the model has predicted the same values for all testing years.
## ARIMAX

First, let's plot the exogenous variables for the study:

```{r}
spain_data_ex <- complete_data %>% 
  filter(country_name == "Spain") %>% 
  select(year, number_deaths, population, gdp_capita) %>% 
  arrange(year)

spain_data_ex

min(spain_data_ex$year)

pob_ts <- ts(spain_data_ex$population, start = 1951, end = 2021, frequency = 1)
gdp_ts <- ts(spain_data_ex$gdp_capita, start = 1960, end = 2021, frequency = 1)
gdp_ts
plot_ts(pob_ts) 
plot_ts(gdp_ts)
```

### Spain

```{r}

```


