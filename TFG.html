<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Margalida Verd Julià">

<title>TFG</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="TFG_files/libs/clipboard/clipboard.min.js"></script>
<script src="TFG_files/libs/quarto-html/quarto.js"></script>
<script src="TFG_files/libs/quarto-html/popper.min.js"></script>
<script src="TFG_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="TFG_files/libs/quarto-html/anchor.min.js"></script>
<link href="TFG_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="TFG_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="TFG_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="TFG_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="TFG_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">TFG</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Margalida Verd Julià </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="installing-data-and-packages" class="level2">
<h2 class="anchored" data-anchor-id="installing-data-and-packages">Installing data and packages</h2>
<p>First, we will install and load the necessary packages for this study. Additionally, we will load the required datasets. The analysis is based on three datasets:</p>
<ul>
<li><p><strong>Mortality</strong>: Downloaded from the World Health Organization, this is the primary dataset for the analysis. It contains the number of tuberculosis-related deaths in all countries. However, our study will focus solely on European countries.</p></li>
<li><p><strong>Population</strong>: From this dataset, we will extract only the population variable. The source of this data is <em>Our World in Data</em>.</p></li>
<li><p><strong>GDP per capita</strong>: Similar to the population dataset, we will extract only the <em>gdp_per_capita</em> variable. The source of this data is <em>Data Bank</em>.</p></li>
</ul>
<p>Let’s examine the structure of the datasets:</p>
<ol type="1">
<li>Mortality:</li>
</ol>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>Rows: 14,692
Columns: 12
$ Region.Code                                                 &lt;chr&gt; "EU", "EU"…
$ Region.Name                                                 &lt;chr&gt; "Europe", …
$ Country.Code                                                &lt;chr&gt; "ALB", "AL…
$ Country.Name                                                &lt;chr&gt; "Albania",…
$ Year                                                        &lt;dbl&gt; 1987, 1997…
$ Sex                                                         &lt;chr&gt; "All", "Al…
$ Age.group.code                                              &lt;chr&gt; "Age_all",…
$ Age.Group                                                   &lt;chr&gt; "[All]", "…
$ Number                                                      &lt;dbl&gt; 47, 19, 10…
$ Percentage.of.cause.specific.deaths.out.of.total.deaths     &lt;dbl&gt; 0.27126861…
$ Age.standardized.death.rate.per.100.000.standard.population &lt;dbl&gt; 2.2548644,…
$ Death.rate.per.100.000.population                           &lt;dbl&gt; 1.5279087,…</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Age_all"</code></pre>
</div>
</div>
<ol start="2" type="1">
<li>Population</li>
</ol>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>Rows: 18,944
Columns: 3
$ Entity                                                &lt;chr&gt; "Afghanistan", "…
$ Year                                                  &lt;int&gt; 1950, 1951, 1952…
$ Population...Sex..all...Age..all...Variant..estimates &lt;dbl&gt; 7776182, 7879343…</code></pre>
</div>
</div>
<ol start="3" type="1">
<li>gdp_per_capita</li>
</ol>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>Rows: 2,629
Columns: 7
$ Series.Name  &lt;chr&gt; "GDP per capita (current US$)", "GDP per capita (current …
$ Series.Code  &lt;chr&gt; "NY.GDP.PCAP.CD", "NY.GDP.PCAP.CD", "NY.GDP.PCAP.CD", "NY…
$ Country.Name &lt;chr&gt; "Albania", "Albania", "Albania", "Albania", "Albania", "A…
$ Country.Code &lt;chr&gt; "ALB", "ALB", "ALB", "ALB", "ALB", "ALB", "ALB", "ALB", "…
$ Time         &lt;int&gt; 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 196…
$ Time.Code    &lt;chr&gt; "YR1960", "YR1961", "YR1962", "YR1963", "YR1964", "YR1965…
$ Value        &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…</code></pre>
</div>
</div>
</section>
<section id="cleaning-data" class="level2">
<h2 class="anchored" data-anchor-id="cleaning-data">Cleaning data</h2>
<p>As seen, we need to standardize the variables names to merge the tables.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Mortality"</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Rows: 14,692
Columns: 12
$ region_code                       &lt;chr&gt; "EU", "EU", "EU", "EU", "EU", "EU", …
$ region_name                       &lt;chr&gt; "Europe", "Europe", "Europe", "Europ…
$ country_code                      &lt;chr&gt; "ALB", "ALB", "ALB", "ALB", "ALB", "…
$ country_name                      &lt;chr&gt; "Albania", "Albania", "Albania", "Al…
$ year                              &lt;dbl&gt; 1987, 1997, 1996, 1996, 1995, 1994, …
$ Sex                               &lt;chr&gt; "All", "All", "Female", "All", "Male…
$ Age.group.code                    &lt;chr&gt; "Age_all", "Age_all", "Age_all", "Ag…
$ Age.Group                         &lt;chr&gt; "[All]", "[All]", "[All]", "[All]", …
$ number_deaths                     &lt;dbl&gt; 47, 19, 10, 34, 10, 13, 26, 39, 12, …
$ percent_cause_specific_death_rate &lt;dbl&gt; 0.27126861, 0.11741441, 0.14432097, …
$ age_death_rate                    &lt;dbl&gt; 2.2548644, 0.8057827, 0.7155687, 1.1…
$ death_rate                        &lt;dbl&gt; 1.5279087, 0.5715489, 0.6027727, 1.0…</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Population"</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Rows: 18,944
Columns: 3
$ country_name &lt;chr&gt; "Afghanistan", "Afghanistan", "Afghanistan", "Afghanistan…
$ year         &lt;int&gt; 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 195…
$ population   &lt;dbl&gt; 7776182, 7879343, 7987783, 8096703, 8207953, 8326981, 845…</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "gdp_per_capita"</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Rows: 2,629
Columns: 4
$ country_name &lt;chr&gt; "Albania", "Albania", "Albania", "Albania", "Albania", "A…
$ country_code &lt;chr&gt; "ALB", "ALB", "ALB", "ALB", "ALB", "ALB", "ALB", "ALB", "…
$ year         &lt;int&gt; 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 196…
$ gdp_capita   &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…</code></pre>
</div>
</div>
<p>The next step is to select the study variables from the mortality dataset. We will exclude <code>Sex</code>, <code>Age.group.code</code> and <code>Age.group</code>.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>Rows: 4,869
Columns: 9
$ region_code                       &lt;chr&gt; "EU", "EU", "EU", "EU", "EU", "EU", …
$ region_name                       &lt;chr&gt; "Europe", "Europe", "Europe", "Europ…
$ country_code                      &lt;chr&gt; "ALB", "ALB", "ALB", "ALB", "ALB", "…
$ country_name                      &lt;chr&gt; "Albania", "Albania", "Albania", "Al…
$ year                              &lt;dbl&gt; 1987, 1997, 1996, 1994, 1992, 1989, …
$ number_deaths                     &lt;dbl&gt; 47, 19, 34, 39, 22, 41, 39, 17, 34, …
$ percent_cause_specific_death_rate &lt;dbl&gt; 0.27126861, 0.11741441, 0.20302144, …
$ age_death_rate                    &lt;dbl&gt; 2.2548644, 0.8057827, 1.1585865, 1.5…
$ death_rate                        &lt;dbl&gt; 1.5279087, 0.5715489, 1.0356381, 1.2…</code></pre>
</div>
</div>
<p>Now, we can merge the remaining two datasets.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>Rows: 1,998
Columns: 11
$ region_code                       &lt;chr&gt; "EU", "EU", "EU", "EU", "EU", "EU", …
$ region_name                       &lt;chr&gt; "Europe", "Europe", "Europe", "Europ…
$ country_code                      &lt;chr&gt; "ALB", "ALB", "ALB", "ALB", "ALB", "…
$ country_name                      &lt;chr&gt; "Albania", "Albania", "Albania", "Al…
$ year                              &lt;dbl&gt; 1987, 1997, 1996, 1994, 1992, 1989, …
$ number_deaths                     &lt;dbl&gt; 47, 19, 34, 39, 22, 41, 39, 17, 34, …
$ percent_cause_specific_death_rate &lt;dbl&gt; 0.27126861, 0.11741441, 0.20302144, …
$ age_death_rate                    &lt;dbl&gt; 2.2548644, 0.8057827, 1.1585865, 1.5…
$ death_rate                        &lt;dbl&gt; 1.5279087, 0.5715489, 1.0356381, 1.2…
$ population                        &lt;dbl&gt; 3148843, 3229665, 3245681, 3269417, …
$ gdp_capita                        &lt;dbl&gt; 674.7934, 717.3800, 1009.9771, 586.4…</code></pre>
</div>
</div>
</section>
<section id="chosen-countries" class="level2">
<h2 class="anchored" data-anchor-id="chosen-countries">Chosen countries</h2>
<p>First, we will define the criteria for dividing European countries into six distinct regions: North, South, West, East, Central, and the Balkans. The Balkans have been designated as a separate region due to their significant cultural differences from neighboring countries. We will add a new variable to the dataset that specifies the subregion to which each country belongs.</p>
<p>The map below shows the division that would be used from this point forward.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="TFG_files/figure-html/unnamed-chunk-9-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>We are considering Greece as part of the Southern region due to the cultural differences with the Balkan countries. Now, we would choose a country to represent each European subregion. We will select five European countries to analyze their trends in the number of tuberculosis-related deaths. The selection criteria will ensure that the chosen countries represent different regions of Europe (e.g., North, South, etc.) while also having a sufficient number of time observations to construct a reliable time series. Additionally, we aim to include countries that exhibit distinct trends in tuberculosis mortality, making the study more insightful by allowing for a comparative analysis and accurate forecasting of different patterns.</p>
<p>As a first step, we will address any missing values (NA) in the dataset for the variable Number_Deaths in each selected country. We are going to choose countries that at least have 40 years with data.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>                                           country_name  n
1                                           Netherlands 73
2                                               Iceland 72
3                                                Sweden 72
4                                               Denmark 71
5                                                France 71
6                                               Ireland 71
7                                                 Spain 71
8                                           Switzerland 71
9  United Kingdom of Great Britain and Northern Ireland 71
10                                              Finland 70
11                                                Italy 70
12                                              Hungary 68
13                                              Austria 67
14                                              Belgium 67
15                                               Norway 66
16                                             Portugal 62
17                                               Poland 61
18                                               Greece 60
19                                              Romania 60
20                                             Bulgaria 58
21                                           Luxembourg 56
22                                                Malta 55
23                                               Latvia 42
24                                              Estonia 40
25                                            Lithuania 40
26                                   Russian Federation 40</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>full_dataset <span class="sc">%&gt;%</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(subregion <span class="sc">==</span> <span class="st">"E"</span>) <span class="sc">%&gt;%</span> </span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">group_by</span>(country_name) <span class="sc">%&gt;%</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summarise</span>(</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">number_deaths =</span> <span class="fu">sum</span>(<span class="sc">!</span><span class="fu">is.na</span>(number_deaths)),</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">population  =</span> <span class="fu">sum</span>(<span class="sc">!</span><span class="fu">is.na</span>(population)),</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">gdp_capita  =</span> <span class="fu">sum</span>(<span class="sc">!</span><span class="fu">is.na</span>(gdp_capita))</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">%&gt;%</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">arrange</span>(<span class="fu">desc</span>(number_deaths)) <span class="sc">%&gt;%</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">data.frame</span>() </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  country_name number_deaths population gdp_capita
1       Latvia            42         42         27
2      Estonia            40         40         30
3    Lithuania            40         40         28
4      Ukraine            35         35         31
5      Belarus            29         29         20</code></pre>
</div>
</div>
<p>Lets study each subregion:</p>
<ul>
<li><p><strong>Southern Europe</strong>. Due to the geographical origin of the authors, we will choose Spain as the representative country of this region.</p></li>
<li><p><strong>Northern Europe</strong>. We observe that Iceland has 72 out of 74 years with recorded values for the selected variable, making it a suitable choice to represent the North region of Europe.</p></li>
<li><p><strong>Western Europe</strong>. As Netherlands is the country with a greatest number of values, it would be our choice for this specific region.</p></li>
<li><p><strong>Eastern Europe</strong>. It is noticeable that eastern countries are the ones with a less number of recorded values (most of them have only 40 or less); then, it would be a special region to analyse. Lithuania will represent the Northeast region, with 40 recorded values. Even though there are nearby countries with longer recorded periods, the tendency of Lithuania stands out among the rest, which will make for an interesting analysis.</p></li>
<li><p><strong>Central Europe</strong>. Switzerland will be the representative country of the central region. It has 71 recorded values, that will fit perfectly when modeling the time series.</p></li>
<li><p><strong>Balkans region</strong>. For the Balkans region, we have selected Romania, which has 60 recorded values. It will be an interesting case of analysis due to its tendency, that is a bit different as the other countries.</p></li>
</ul>
<p>The selection criteria prioritize minimizing the number of missing values (NA) while ensuring a diverse representation of different regions in Europe. As we have discussed trends, let’s display the trend in tuberculosis-related deaths for the selected countries.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="TFG_files/figure-html/unnamed-chunk-12-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="data-partitioning-utilities" class="level2">
<h2 class="anchored" data-anchor-id="data-partitioning-utilities">Data partitioning utilities</h2>
<p>To standardize the modeling process across multiple countries, we define helper structures that facilitate consistent data handling. Specifically, we construct a country_splits hashmap to store the full, training, and testing datasets for each selected country.</p>
<p>The first step is to initialize this structure with the full dataset filtered by country and ordered by year:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>country_splits <span class="ot">&lt;-</span> <span class="fu">hashmap</span>()</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>chosen_countries <span class="ot">=</span> <span class="fu">c</span>(<span class="st">"Spain"</span>, <span class="st">"Netherlands"</span>, <span class="st">"Sweden"</span>, <span class="st">"Switzerland"</span>, <span class="st">"Romania"</span>, <span class="st">"Latvia"</span>)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (name <span class="cf">in</span> chosen_countries) {</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  country_splits[[name]][[<span class="st">"full"</span>]] <span class="ot">&lt;-</span> full_dataset <span class="sc">%&gt;%</span> <span class="fu">filter</span>(country_name <span class="sc">==</span> name) <span class="sc">%&gt;%</span>  <span class="fu">arrange</span>(year)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Next, we define the specific number of years to allocate to the testing set for each country. These values were chosen based on the total number of available observations, ensuring approximately 15–20% of the series is reserved for out-of-sample evaluation.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>test_lengths_per_country <span class="ot">=</span> <span class="fu">hashmap</span>()</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>test_lengths_per_country[[<span class="st">"Spain"</span>]] <span class="ot">=</span> <span class="dv">11</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>test_lengths_per_country[[<span class="st">"Switzerland"</span>]] <span class="ot">=</span> <span class="dv">11</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>test_lengths_per_country[[<span class="st">"Sweden"</span>]] <span class="ot">=</span> <span class="dv">11</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>test_lengths_per_country[[<span class="st">"Latvia"</span>]] <span class="ot">=</span> <span class="dv">11</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>test_lengths_per_country[[<span class="st">"Netherlands"</span>]] <span class="ot">=</span> <span class="dv">12</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>test_lengths_per_country[[<span class="st">"Romania"</span>]] <span class="ot">=</span> <span class="dv">10</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Finally, we split the dataset for each country into a training and a testing subset based on the predefined test lengths. This setup is essential for subsequent model fitting and forecast evaluation.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (country <span class="cf">in</span> chosen_countries) {</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  country_dataset <span class="ot">=</span> country_splits[[country]]<span class="sc">$</span>full</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  total_len <span class="ot">=</span> <span class="fu">nrow</span>(country_dataset)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>  test_len <span class="ot">=</span> test_lengths_per_country[[country]]</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  country_splits[[country]][[<span class="st">"train"</span>]] <span class="ot">=</span> country_dataset[<span class="dv">1</span><span class="sc">:</span>(total_len <span class="sc">-</span> test_len ),]</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>  country_splits[[country]][[<span class="st">"test"</span>]] <span class="ot">=</span> country_dataset[(total_len <span class="sc">-</span> test_len <span class="sc">+</span> <span class="dv">1</span>)<span class="sc">:</span>total_len,]</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We now define two utility functions. The first is designed to automate the selection of ARIMA models by systematically evaluating various parameter combinations and reporting their corresponding Akaike Information Criterion (AIC) values. This approach allows for an informed and reproducible model selection process, particularly useful when the number of possible <span class="math inline">\((p,d,q)\)</span> combinations is large and exhaustive testing is impractical.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>try_all_arima <span class="ot">&lt;-</span> <span class="cf">function</span>(ar_coef, d_coef, ma_coef, time_series) {</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (p <span class="cf">in</span> ar_coef) {</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span>(d <span class="cf">in</span> d_coef) {</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> (q <span class="cf">in</span> ma_coef) {</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>      arima_fit <span class="ot">&lt;-</span> <span class="fu">Arima</span>(time_series, <span class="at">order =</span> <span class="fu">c</span>(p, d, q))</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>      <span class="fu">cat</span>(<span class="st">"ARIMA("</span>, p, <span class="st">","</span>, d,<span class="st">","</span> ,q, <span class="st">")</span><span class="sc">\n</span><span class="st">"</span>, <span class="at">sep =</span> <span class="st">""</span>)</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>      <span class="fu">print</span>(arima_fit<span class="sc">$</span>coef)</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>      <span class="fu">cat</span>(<span class="st">"AIC:"</span>, <span class="fu">AIC</span>(arima_fit), <span class="st">"</span><span class="sc">\n\n</span><span class="st">"</span>)</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This function iterates over all specified combinations of autoregressive (AR), differencing (I), and moving average (MA) orders. For each configuration, it fits an ARIMA model and outputs the estimated parameters along with the AIC value, which serves as the model selection criterion.</p>
<p>The second function is responsible for fitting an ARIMA model to the training series of a given country. It takes as input the ARIMA parameters <span class="math inline">\((p,d,q)\)</span> and a country name, and includes an optional boolean argument, <code>log_transform</code>. This parameter allows the user to specify whether the time series should be log-transformed prior to model fitting. This functionality ensures flexibility in handling different types of data distributions, particularly those exhibiting heteroscedasticity or exponential decay patterns. It uses the <code>Arima()</code> function of the <code>forecast</code> package.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>fit_arima <span class="ot">&lt;-</span> <span class="cf">function</span>(p, d, q, country, <span class="at">log_transform =</span> <span class="cn">TRUE</span>) {</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  series <span class="ot">&lt;-</span> country_splits[[country]]<span class="sc">$</span>train<span class="sc">$</span>number_deaths</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (log_transform) {</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    series <span class="ot">&lt;-</span> <span class="fu">log</span>(series)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>  train_ts <span class="ot">&lt;-</span> <span class="fu">ts</span>(series)</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>  arima_fit <span class="ot">&lt;-</span> <span class="fu">Arima</span>(train_ts, <span class="at">order =</span> <span class="fu">c</span>(p, d, q))</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(arima_fit)</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Finally, we define the get_length function to facilitate quick retrieval of the number of non-missing observations in a specified dataset. Accessing time series lengths manually for each country and subset (full, train, or test) can be cumbersome and error-prone. This utility function simplifies the process by requiring only the country name, the desired subset, and the target variable. It returns the number of valid (non-NA) entries.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>get_length <span class="ot">&lt;-</span> <span class="cf">function</span>(country, set, variable) {</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">length</span>(<span class="fu">na.omit</span>(country_splits[[country]][[set]][[variable]])))</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="arima-models" class="level2">
<h2 class="anchored" data-anchor-id="arima-models">ARIMA models</h2>
<p>In this section, we analyze the temporal dynamics of tuberculosis-related mortality across the selected European countries using ARIMA models. Each country will be studied individually, beginning with an exploratory analysis of the log-transformed mortality data. Model parameters (p,d,q) will be selected based on empirical diagnostics such as the ACF/PACF plots and the AIC. The adequacy of each model will be verified through residual analysis.</p>
<section id="spain" class="level3">
<h3 class="anchored" data-anchor-id="spain">Spain</h3>
<p>We begin our analysis with the Spanish dataset, which spans from 1951 to 2021 and comprises 71 annual observations. Given the long time span and the observed declining trend in raw counts, a logarithmic transformation is applied to stabilize variance and linearize the trend. The figure below shows the log-transformed training time series for tuberculosis mortality in Spain.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="TFG_files/figure-html/unnamed-chunk-19-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Next, we check the ACF and PACF plots:</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="TFG_files/figure-html/unnamed-chunk-20-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="TFG_files/figure-html/unnamed-chunk-20-2.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>The ACF shows very high autocorrelation at the initial lags, which gradually decays in an exponential trend. In contrast, the PACF displays a single significant spike at lag 1, with all subsequent lags falling within the confidence bounds. This pattern is consistent with an AR(<span class="math inline">\(1\)</span>) process applied to a non-stationary series.</p>
<p>In order to formally assess whether the series is stationary, we apply the Augmented Dickey-Fuller (ADF) test:</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>
    Augmented Dickey-Fuller Test

data:  train_spain
Dickey-Fuller = 0.097996, Lag order = 3, p-value = 0.99
alternative hypothesis: stationary</code></pre>
</div>
</div>
<p>As expected, the high <span class="math inline">\(p\)</span>-value indicates that we fail to reject the null hypothesis, which suggests that the series is non-stationary. In this case, applying a first-order difference is recommended.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="TFG_files/figure-html/unnamed-chunk-22-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>We can apply the ADF test to the differenced time series:</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>
    Augmented Dickey-Fuller Test

data:  train_spain_diff
Dickey-Fuller = -4.729, Lag order = 3, p-value = 0.01
alternative hypothesis: stationary</code></pre>
</div>
</div>
<p>The test <span class="math inline">\(p\)</span>-value ensures the stationarity of the time series. Now, we check the ACF and PACF of the differenced time series:</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="TFG_files/figure-html/unnamed-chunk-24-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="TFG_files/figure-html/unnamed-chunk-24-2.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>The ACF of the differenced log-transformed series shows a strong spike at lag 0, which is expected since any time series is perfectly correlated with itself at lag 0. Beyond that, no significant spikes appear—autocorrelations at higher lags lie well within the confidence bounds. This suggests there is no strong moving average (MA) structure in the differenced series.</p>
<p>Similarly, the PACF displays only minor fluctuations, with all values remaining inside the confidence intervals. This indicates no clear autoregressive (AR) component is present either.</p>
<p>Now, we need to choose the order for the ARIMA models; in general, the selection is based on the ACF and PACF. However, since the ACF and PACF show no other AR or MA components, we will use the function <code>auto.arima()</code> from the <code>forecast</code>package in order to determine the best model, based on the AIC criterion. Also, we will fit the ARIMA(<span class="math inline">\(0,1,0\)</span>), that is the result of differencing the series.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>Series: train_spain 
ARIMA(0,2,1) 

Coefficients:
          ma1
      -0.8879
s.e.   0.1038

sigma^2 = 0.009617:  log likelihood = 52.12
AIC=-100.25   AICc=-100.03   BIC=-96.13

Training set error measures:
                     ME       RMSE        MAE       MPE      MAPE      MASE
Training set 0.03225218 0.09558519 0.07227277 0.3824838 0.9657097 0.8412927
                    ACF1
Training set -0.03232125</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Series: train_spain 
ARIMA(0,1,0) 

sigma^2 = 0.01435:  log likelihood = 41.49
AIC=-80.98   AICc=-80.91   BIC=-78.9

Training set error measures:
                     ME      RMSE        MAE        MPE     MAPE      MASE
Training set -0.0698718 0.1187758 0.08464459 -0.8977003 1.126487 0.9853071
                    ACF1
Training set -0.08631941</code></pre>
</div>
</div>
<p>The ARIMA autogenerated is an ARIMA(0,2,1), meaning that it has differenced the series twice and has an MA component left. The AIC is quite low (<span class="math inline">\(-100,25\)</span>), indicating that it can be a good model. Looking at the error measures of the training set, the model shows good performance, with an RMSE of <span class="math inline">\(0.096\)</span> and a MAPE below <span class="math inline">\(1\)</span>% on the log-transformed training set. The low MAE and near-zero ACF1 (<span class="math inline">\(-0.03\)</span>) indicate well-behaved residuals and a solid overall fit.</p>
<p>The ARIMA(<span class="math inline">\(0,1,0\)</span>) has also a small AIC (<span class="math inline">\(-80,98\)</span>); the model yields moderate in-sample accuracy, with an RMSE of <span class="math inline">\(0.119\)</span> and a MAPE of <span class="math inline">\(1.13\)</span>% on the log-transformed training set. Although the error metrics are acceptable, the higher MAE and MASE values suggest less precise fitting. The residual autocorrelation (ACF1 = <span class="math inline">\(-0.086\)</span>) is low, indicating that no substantial temporal structure remains unmodeled.</p>
<p>Before the forecast, we need to check on the residuals of both models.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="TFG_files/figure-html/unnamed-chunk-26-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
    Ljung-Box test

data:  Residuals from ARIMA(0,2,1)
Q* = 11.553, df = 9, p-value = 0.2397

Model df: 1.   Total lags used: 10</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
    Shapiro-Wilk normality test

data:  residuals(fit_spain_auto)
W = 0.98909, p-value = 0.8701</code></pre>
</div>
</div>
<p>The ARIMA(<span class="math inline">\(0,2,1\)</span>) passes both the Ljung-Box test and the Shapiro-Wilk normality test, indicating that the residuals do not present any temporal structure left.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="TFG_files/figure-html/unnamed-chunk-27-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
    Ljung-Box test

data:  Residuals from ARIMA(0,1,0)
Q* = 3.3929, df = 10, p-value = 0.9706

Model df: 0.   Total lags used: 10</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
    Shapiro-Wilk normality test

data:  residuals(fit_spain_010)
W = 0.88402, p-value = 3.614e-05</code></pre>
</div>
</div>
<p>In contrast, the ARIMA(<span class="math inline">\(0,1,0\)</span>) does not pass the normality test for residuals. To mitigate the potencial impact of non-normal residuals on forecast, we apply a bootstrap approach during forecasting.</p>
<p>In the <code>forecast()</code> function, setting <code>bootstrap = TRUE</code> generates forecast intervals by resampling the residuals rather than assuming they follow a normal distribution. This produces more robust and data-driven prediction intervals when the normality assumption is violated.</p>
<p>We now proceed with the forecasting stage. The forecast horizon is set to match the length of the test set, ensuring a direct comparison between predicted and actual values. A confidence level of <span class="math inline">\(95\)</span>% is used, meaning that each forecasted point is accompanied by an interval within which the true value is expected to lie with <span class="math inline">\(95\)</span>% probability.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>     Point Forecast    Lo 95    Hi 95
2011       5.935681 5.743471 6.127892
2012       5.900101 5.612641 6.187561
2013       5.864520 5.493046 6.235995
2014       5.828940 5.377328 6.280552
2015       5.793359 5.262850 6.323869
2016       5.757779 5.148368 6.367190
2017       5.722199 5.033209 6.411188
2018       5.686618 4.916981 6.456255
2019       5.651038 4.799442 6.502633
2020       5.615457 4.680441 6.550473
2021       5.579877 4.559882 6.599871</code></pre>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="TFG_files/figure-html/unnamed-chunk-29-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="TFG_files/figure-html/unnamed-chunk-29-2.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Now, although the model has captured the downward trend of the time series, it has predicted a quasi-linear trend. Now, we can plot the real values versus the predicted ones, on the logarithmic scale.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="TFG_files/figure-html/unnamed-chunk-30-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>To finally determine that the model does not predict correctly the test values, we check the error measures:</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>         Model         ME      RMSE       MPE       MAE     MAPE
1 ARIMA(0,2,1) -0.2497739 0.2614052 -4.577223 0.2497739 4.577223</code></pre>
</div>
</div>
<p>The ARIMA(<span class="math inline">\(0,2,1\)</span>) model produced a Mean Error of <span class="math inline">\(–0.25\)</span> and a RMSE of <span class="math inline">\(0.26\)</span> on the log-transformed test set, indicating a mild tendency to overestimate. The MPE and MAPE were <span class="math inline">\(–4.58\)</span>% and <span class="math inline">\(4.58\)</span>%, respectively. These values suggest that, on average, the model overpredicts tuberculosis deaths by approximately <span class="math inline">\(4.6\)</span>%.</p>
<p>Now, we do the same analysis for the ARIMA(<span class="math inline">\(0,1,0\)</span>).</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>     Point Forecast    Lo 95    Hi 95
2011       5.971262 5.715572 6.144812
2012       5.971262 5.607353 6.192232
2013       5.971262 5.568554 6.244105
2014       5.971262 5.535746 6.286711
2015       5.971262 5.498785 6.321388
2016       5.971262 5.462480 6.365857
2017       5.971262 5.419423 6.392885
2018       5.971262 5.386113 6.437647
2019       5.971262 5.349732 6.461049
2020       5.971262 5.328874 6.500957
2021       5.971262 5.287891 6.526952</code></pre>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="TFG_files/figure-html/unnamed-chunk-33-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="TFG_files/figure-html/unnamed-chunk-33-2.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>The model has predicted a constant line, indicating that it is not a good model for the data. To assess formally this fact, we study the error measures on the test set.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>         Model         ME      RMSE       MPE       MAE     MAPE
1 ARIMA(0,1,0) -0.4632568 0.4937955 -8.516931 0.4632568 8.516931</code></pre>
</div>
</div>
<p>The ARIMA(<span class="math inline">\(0,1,0\)</span>) model yields relatively poor forecast performance, with a high RMSE of <span class="math inline">\(0.49\)</span> and a MAPE of <span class="math inline">\(8.52\)</span>% on the log-transformed test set. The negative ME and MPE values indicate a consistent overestimation of tuberculosis deaths, suggesting that the model fails to adequately capture the underlying downward trend.</p>
<p>The final conclusion is that the current models are too simple to forecast this series. We will now manually select another model and examine whether a more complex model can predict the series more accurately.</p>
<p>We will use the <code>try_all_arima</code> function. We choose a 1 order difference, as the series showed stationarity after the differencing.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>ARIMA(2,1,2)
         ar1          ar2          ma1          ma2 
-0.004654059  0.993486141  0.093930795 -0.881104408 
AIC: -99.51884 

ARIMA(2,1,3)
         ar1          ar2          ma1          ma2          ma3 
-0.004886725  0.993160476  0.090160877 -0.879160544  0.005159314 
AIC: -97.52028 

ARIMA(3,1,2)
        ar1         ar2         ar3         ma1         ma2 
 1.08885758  0.09807324 -0.19167437 -1.01852984  0.10041450 
AIC: -95.40798 

ARIMA(3,1,3)
       ar1        ar2        ar3        ma1        ma2        ma3 
 0.8149055 -0.5306605  0.7034761 -0.7567726  0.8752013 -0.8960248 
AIC: -97.24188 </code></pre>
</div>
</div>
<p>The function shows that the two models with the smallest AIC is the ARIMA(<span class="math inline">\(2,1,2\)</span>).</p>
<p>We check the residuals of the models:</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="TFG_files/figure-html/unnamed-chunk-36-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
    Ljung-Box test

data:  Residuals from ARIMA(2,1,2)
Q* = 3.9273, df = 6, p-value = 0.6865

Model df: 4.   Total lags used: 10</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
    Shapiro-Wilk normality test

data:  residuals(fit_spain_212)
W = 0.94445, p-value = 0.008611</code></pre>
</div>
</div>
<p>The residuals of the ARIMA(<span class="math inline">\(2,1,2\)</span>) satisfy both hypothesis of normality and no autocorrelation left.</p>
<p>Now, we begin the forecast:</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>     Point Forecast    Lo 95    Hi 95
2011       5.963683 5.773824 6.153541
2012       5.905125 5.625066 6.185184
2013       5.897868 5.536752 6.258983
2014       5.839725 5.404023 6.275427
2015       5.832786 5.322479 6.343092
2016       5.775054 5.192366 6.357742
2017       5.768429 5.111700 6.425158
2018       5.711104 4.981288 6.440919
2019       5.704788 4.899751 6.509825
2020       5.647867 4.768036 6.527697
2021       5.641857 4.684961 6.598753</code></pre>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="TFG_files/figure-html/unnamed-chunk-38-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="TFG_files/figure-html/unnamed-chunk-38-2.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>The plot shows how a higher order of the parameters, starts to capture the oscillating behavior of the series. Let’s check the error measures of the test data:</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>         Model        ME      RMSE       MPE      MAE     MAPE
1 ARIMA(2,1,2) -0.281839 0.2959692 -5.167253 0.281839 5.167253</code></pre>
</div>
</div>
<p>The ARIMA(<span class="math inline">\(2,1,2\)</span>) model exhibits a slight overestimation bias but maintains moderate error magnitude (RMSE = <span class="math inline">\(0.296\)</span>, MAE = <span class="math inline">\(0.282\)</span>) on the log scale. Its MPE of <span class="math inline">\(–5.17\)</span>% and MAPE of <span class="math inline">\(5.17\)</span>% indicate forecasts deviate by just over <span class="math inline">\(5\)</span>% from actual values, reflecting a reasonable balance between accuracy and complexity.</p>
<p>Finally, we can plot the predicted values versus the real values, on the logarithmic scale.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="TFG_files/figure-html/unnamed-chunk-40-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p><strong>Final conclusions</strong></p>
<p>Let’s do a summary of the Spain models applied; we are going to change the scale into the original one.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>         Model         ME      RMSE       MPE       MAE     MAPE
1 ARIMA(0,2,1)  -68.47054  70.10365 -28.76170  68.47054 28.76170
2 ARIMA(0,1,0) -141.81818 147.63961 -61.32746 141.81818 61.32746
3 ARIMA(2,1,2)  -78.50731  80.62235 -33.10781  78.50731 33.10781</code></pre>
</div>
</div>
<p>The out‐of‐sample comparison on the original (untransformed) scale shows that ARIMA(<span class="math inline">\(0,2,1\)</span>) achieves the lowest overall error among the three candidates. Specifically, its RMSE of <span class="math inline">\(70.10\)</span> and MAE of <span class="math inline">\(68.47\)</span> indicate smaller average forecast deviations compared to ARIMA(0,1,0) (RMSE = <span class="math inline">\(147.64\)</span>, MAE = <span class="math inline">\(141.82\)</span>) and ARIMA(2,1,2) (RMSE = <span class="math inline">\(80.62\)</span>, MAE = <span class="math inline">\(78.51\)</span>). In percentage terms, ARIMA(<span class="math inline">\(0,2,1\)</span>) yields a MAPE of <span class="math inline">\(28.76\)</span>%, which is nearly half of ARIMA(<span class="math inline">\(0,1,0\)</span>)’s <span class="math inline">\(61.33\)</span>% and substantially better than ARIMA(<span class="math inline">\(2,1,2\)</span>)’s <span class="math inline">\(33.11\)</span>%. Although all three models exhibit a modest overestimation bias (negative ME and MPE), ARIMA(<span class="math inline">\(0,2,1\)</span>) overpredicts by an average of only <span class="math inline">\(68\)</span> deaths (<span class="math inline">\(–28.76\)</span>% relative bias), whereas ARIMA(<span class="math inline">\(0,1,0\)</span>) and ARIMA(<span class="math inline">\(2,1,2\)</span>) overestimate by <span class="math inline">\(142\)</span> (<span class="math inline">\(–61.33\)</span>%) and <span class="math inline">\(79\)</span> (<span class="math inline">\(–33.11\)</span>%) deaths, respectively.</p>
<p>Taken together, these results demonstrate that ARIMA(<span class="math inline">\(0,2,1\)</span>) best balances predictive accuracy for tuberculosis mortality in Spain.. Consequently, ARIMA(<span class="math inline">\(0,2,1\)</span>) is the preferred model for forecasting this series.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="TFG_files/figure-html/unnamed-chunk-43-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Although ARIMA(<span class="math inline">\(0,2,1\)</span>) achieved the lowest numerical errors, its fitted trajectory clearly overestimates the true decline in TB deaths (see the plot). However, because the forecast curve from ARIMA(<span class="math inline">\(0,2,1\)</span>) decays too gradually and remains well above the actual values after 2015, it fails to capture the accelerated drop in mortality.</p>
<p>In light of this discrepancy between numerical error metrics and visual fit, ARIMA(<span class="math inline">\(0,2,1\)</span>) does not adequately reproduce the sharp downturn observed in the test period. Therefore, despite its lower AIC and error measures, ARIMA(<span class="math inline">\(0,2,1\)</span>) is not optimal.</p>
</section>
</section>
<section id="arimax-models" class="level2">
<h2 class="anchored" data-anchor-id="arimax-models">ARIMAX models</h2>
<p>We have seen that ARIMA models are quite simple in order to do a well-suited forecast for our studied series. In this section we will study ARIMAX models; ARIMAX models are ARIMA models that include some exogenous variables in order to get better forecastings rather than basic ARIMA. In our study, we will consider two exogenous variables: Gross Domestic Product per capita and the country population.</p>
<p>First, we visualize these series.</p>
<p>We begin analysing the Population variable.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="TFG_files/figure-html/unnamed-chunk-45-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>In stark contrast with the other countries, Spain population has a strong increasing trend, reaching nearly 50 million in 2010. Romania follows Spain as the second country with a bigger population; however, the difference between both countries is nearly 20 million. The Netherlands, Sweden and Switzerland present similar increasing trends. Finally, Latvia is the country with the lowest population. Moreover, it shows a slow decaying tendency from beyond the 1990. More information: WIKIPEDIA (Letonia perdió más de un 23% de su población por dos factores: la caída de su tasa de fertilidad, y un saldo migratorio negativo que se acentuó con la crisis económica de 2008.)</p>
<section id="spain-1" class="level3">
<h3 class="anchored" data-anchor-id="spain-1">Spain</h3>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>